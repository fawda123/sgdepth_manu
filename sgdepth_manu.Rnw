\documentclass[letterpaper,12pt,oneside]{article}
\usepackage[paperwidth=8.5in,paperheight=11in,top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{setspace}
\usepackage[colorlinks=true,allcolors=Blue]{hyperref}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{rotating}
\usepackage{tabularx}
\usepackage{outlines}
\usepackage{lineno}
\usepackage{array}
\usepackage{times}
\usepackage{cleveref}
\usepackage{acronym}
\usepackage[position=t]{subfig}
\usepackage{paralist}
\usepackage[noae]{Sweave}
\usepackage{natbib}
\usepackage{array}
\usepackage{pdflscape}
\usepackage{bm}
% \usepackage{showlabels}
\bibpunct{(}{)}{,}{a}{}{,}

% page margins and section title formatting
\linespread{1.5}
\setlength{\footskip}{0.5in}
\titleformat*{\section}{\Large\bf\em}
\titleformat*{\subsection}{\singlespace\large\bf}
\titleformat*{\subsubsection}{\singlespace\normalsize\bf\em}
\titlespacing{\section}{0in}{0in}{0in}
\titlespacing{\subsection}{0in}{0in}{0in}
\titlespacing{\subsubsection}{0in}{0in}{0in}

% cleveref options
\crefname{table}{Table}{Tables}
\crefname{figure}{Fig.}{Figs.}
\renewcommand{\figurename}{Fig.}

% aliased citations
\defcitealias{FLDEP12}{FLDEP 2012}
\defcitealias{HagyIR}{Hagy In review}
\defcitealias{USEPA06}{USEPA 2006}
\defcitealias{USEPA98}{USEPA 1998}

%acronyms
\acrodef{DEM}{Digital Elevation Model}
\acrodef{doc}[$Z_c$]{depth of colonization}
\acrodef{IWR}{Impaired Waters Rule}
\acrodef{NAVD88}{North American Vertical Datum of 1988}
\acrodef{NOAA}{National Oceanic and Atmospheric Administration}

%for supplemental figures/tables
\newcommand{\beginsupplement}{%
        \setcounter{table}{0}
        \renewcommand{\thetable}{S\arabic{table}}%
        \setcounter{figure}{0}
        \renewcommand{\thefigure}{S\arabic{figure}}%
     }

%knitr options
<<setup,include=F,cache=F>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path = 'figs/', fig.align='center', fig.show='hold',message=F,echo=F,results='asis',dev='pdf',dev.args=list(family='serif'),fig.pos='!ht',warning=F)
options(replace.assign=TRUE,width=90,digits=1)

source('R/funcs.r')
library(tidyr)
library(dplyr)
library(purrr)
library(nlme)
library(ggsn)
library(ggrepel)
library(directlabels)
library(grid)
@

% get the version based on commit date
<<echo = FALSE, cache = FALSE>>=
raw <- system('git log -1', intern = TRUE)
raw <- raw[grep('^Date', raw)]
raw <- paste('Version', raw)
@

% get online bib file
<<echo = FALSE, cache = FALSE>>=
refs <- httr::GET('https://raw.githubusercontent.com/fawda123/refs/master/refs.bib')
refs <- rawToChar(refs$content)
writeLines(refs, con = file('refs.bib'))
@

\begin{document}

\raggedbottom
\linenumbers
\raggedright
\urlstyle{same}
\setlength{\parindent}{0.5in}
\renewcommand\refname{References \vspace{12pt}}

\begin{singlespace}
\title{{\bf {\Large Quantifying seagrass light requirements using an algorithm to spatially resolve depth of colonization}}}
\author{
  {\bf {\normalsize Marcus W. Beck$^1$, James D. Hagy III$^2$, Chengfeng Le$^3$}}
  \\\\{\textit {\normalsize $^1$ORISE Research Participation Program}}
  \\{\textit {\normalsize USEPA National Health and Environmental Effects Research Laboratory}}
  \\{\textit {\normalsize Gulf Ecology Division, 1 Sabine Island Drive, Gulf Breeze, FL 32561}}
	\\{\textit {\normalsize Phone: 850-934-2480, Fax: 850-934-2401, Email: \href{mailto:beck.marcus@epa.gov}{beck.marcus@epa.gov}}}
  \\\\{\textit {\normalsize $^2$USEPA National Health and Environmental Effects Research Laboratory}}
	\\{\textit {\normalsize Gulf Ecology Division, 1 Sabine Island Drive, Gulf Breeze, FL 32561}}
	\\{\textit {\normalsize Phone: 850-934-2455, Fax: 850-934-2401, Email: \href{mailto:hagy.jim@epa.gov}{hagy.jim@epa.gov}}}
  \\\\{\textit {\normalsize $^3$ORISE Research Participation Program}}
  \\{\textit {\normalsize USEPA National Health and Environmental Effects Research Laboratory}}
  \\{\textit {\normalsize Gulf Ecology Division, 1 Sabine Island Drive, Gulf Breeze, FL 32561}}
  \\{\textit {\normalsize Phone: 850-934-9308, Fax: 850-934-2401, Email: \href{mailto:le.chengfeng@epa.gov}{le.chengfeng@epa.gov}}}
  \vspace{1in} 
  \\ \Sexpr{raw}
	}
\date{}
\maketitle
\end{singlespace}
\clearpage

<<echo = F>>=
# load data
data(irl_light)
data(tb_light)
data(choc_light)
irl <- data.frame(irl_light)
tb <- data.frame(tb_light)
choc <- data.frame(choc_light)

# light requirement ranges for each bay
choc_rng <- range(choc$light, na.rm = T)
irl_rng <- range(irl$light, na.rm = T)
tb_rng <- range(tb$light, na.rm = T)
@

% data for inline expressions
<<echo = F>>=
data(seg_summ)

# surface areas
areas <- seg_summ[row.names(seg_summ) %in% 'Surface area',]
areas <- as.numeric(areas)
names(areas) <- names(seg_summ)

# seagrass percent coverage
sgperc <- seg_summ[row.names(seg_summ) %in% 'Seagrass area',]
sgperc <- 100 * as.numeric(sgperc) / areas
names(sgperc) <- names(seg_summ)

# mean depth
depths <- seg_summ[row.names(seg_summ) %in% 'Depth (mean)',]
depths <- as.numeric(depths)
names(depths) <- names(seg_summ)

#max depths
mdepths <- seg_summ[row.names(seg_summ) %in% 'Depth (max)',]
mdepths <- as.numeric(mdepths)
names(mdepths) <- names(seg_summ)

# secchi depths
secchis <- seg_summ[row.names(seg_summ) %in% 'Secchi (mean)',]
secchis <- as.numeric(secchis)
names(secchis) <- names(seg_summ)
@

% seagrass estimates from table
<<echo = F>>=
data(ests_seg)
data(ests_out)

# big bend doc max diff
bb_ests <- mean(ests_out[ests_out$seg == '820', 'z_cmax'])

# irl estimates
irl_maxdocmin <- max(ests_out[ests_out$seg == '1502', c('z_cmin')])
irl_meandocmax <- mean(ests_out[ests_out$seg == '1502', c('z_cmax')])
irl_maxdocmax <- max(ests_out[ests_out$seg == '1502', c('z_cmax')])
@

<<echo = F>>=
data(ests_out)
data(ests_out_nonsigs)

# uncertainty means
means <- dplyr::group_by(ests_out, seg) %>% 
  summarize(means = mean(confint, na.rm = T)) %>% 
  as.data.frame(.)

# uncertainty means
maxs <- dplyr::group_by(ests_out, seg) %>% 
  summarize(maxs = max(confint, na.rm = T)) %>% 
  as.data.frame(.)

# percent non-overlapping
# 'overlapped' indicates percent non-different between depth measures
# interval is non-symmetric but this does not affect overlap
overlap <- dplyr::mutate(ests_out, halved = confint/2) %>% 
  mutate(
    overlapped = (z_cmax - halved) < (z_cmed + halved)
  ) %>% 
  group_by(seg) %>% 
  summarize(
    overlapped = 100 * sum(overlapped)/length(overlapped)
  ) %>% 
  as.data.frame(.)

# of those that were estimable, which had z_cmax sig greater than zero?
nonsigs <- dplyr::mutate(ests_out_nonsigs,
    ltzero = lower_max < 0
  ) %>% 
  group_by(seg) %>% 
  summarize(
    ltzero = 100 * sum(ltzero)/length(ltzero)
  ) %>% 
  as.data.frame(.)

@

<<echo = F>>=
# load data
data(irl_light)
data(tb_light)
data(choc_light)
irl <- data.frame(irl_light)
tb <- data.frame(tb_light)
choc <- data.frame(choc_light)

# aov of zmax between bays
zcall <- reshape2::melt(
  list(tb = tb$z_c_all, irl = irl$z_c_all, choc = choc$z_c_all)
  )
zcall_means <- aggregate(value ~ L1, data = zcall, FUN = mean)
zcall_means <- split(zcall_means$value, zcall_means$L1)
zcall_aov <- summary(lm(value ~ L1, data = zcall))$fstatistic
zcall_aov <- c(zcall_aov, pf(zcall_aov[1], zcall_aov[2], zcall_aov[3],lower.tail=F))
names(zcall_aov) <- c('Fval', 'df1', 'df2', 'pval')
zcall_tuk <- aov(value ~ L1, data = zcall)
zcall_tuk <- TukeyHSD(zcall_tuk)

# aov between bays
light_btw <- reshape2::melt(
  list(tb = tb$light, irl = irl$light, choc = choc$light)
  )
light_btw_means <- aggregate(value ~ L1, data = light_btw, FUN = mean)
aov_btw <- summary(lm(value ~ L1, data = light_btw))$fstatistic
aov_btw <- c(aov_btw, pf(aov_btw[1], aov_btw[2], aov_btw[3],lower.tail=F))
names(aov_btw) <- c('Fval', 'df1', 'df2', 'pval')
tuk_btw <- aov(value ~ L1, data = light_btw)
tuk_btw <- TukeyHSD(tuk_btw)

# light within bays
wtn_tb <- summary(lm(light ~ seg, data = tb))$fstatistic
wtn_tb <- c(wtn_tb, pf(wtn_tb[1], wtn_tb[2], wtn_tb[3],lower.tail=F))
names(wtn_tb) <- c('Fval', 'df1', 'df2', 'pval')
wtn_irl <- summary(lm(light ~ seg, data = irl))$fstatistic
wtn_irl <- c(wtn_irl, pf(wtn_irl[1], wtn_irl[2], wtn_irl[3],lower.tail=F))
names(wtn_irl) <- c('Fval', 'df1', 'df2', 'pval')
wtn_choc <- summary(lm(light ~ seg, data = choc))$fstatistic
wtn_choc <- c(wtn_choc, pf(wtn_choc[1], wtn_choc[2], wtn_choc[3],lower.tail=F))
names(wtn_choc) <- c('Fval', 'df1', 'df2', 'pval')

# tukey comps
tuk_tb <- aov(light ~ seg, data = tb)
tuk_tb <- TukeyHSD(tuk_tb)$seg[, 'p adj']
# tuk_tb <- tuk_tb[tuk_tb < 0.05]
tuk_irl <- aov(light ~ seg, data = irl)
tuk_irl <- TukeyHSD(tuk_irl)$seg[, 'p adj']
# tuk_irl <- tuk_irl[tuk_irl < 0.05]
tuk_choc <- aov(light ~ seg, data = choc)
tuk_choc <- TukeyHSD(tuk_choc)$seg[, 'p adj']
# tuk_choc <- tuk_choc[tuk_choc < 0.05]
@

% dixon compare
<<eval = F>>=
source('R/funcs.r')

# load data
data(tb_sats)
data(tb_seg)
data(sgpts_2010_tb)
ave_rast <- tb_sats[['ave_rast']]

# create sampling grid, 0.01 dec degree spacing
tb_grd <- grid_est(tb_seg, 0.01)

# dixon locations
locs <- data.frame(
  westd = rep(-82, 4),
  westm = c(-41.4, -38.5, -35, -40.1)/60,
  northd = rep(27, 4), 
  northm = c(38.3, 41.8, 37.5, 31.8)/60 
)
locs <- with(locs, data.frame(
  west = westd + westm,
  north = northd + northm 
))

# sample the satellit clarity raster
samp_vals <- raster::extract(ave_rast, locs, sp = T) %>% 
  data.frame  
samp_vals <- cbind(samp_vals, data.frame(locs))
names(samp_vals) <- c('clarity', 'Longitude', 'Latitude')
coordinates(samp_vals) <- c('Longitude', 'Latitude')

# process for seagrass depth limits and light requirements
proc <- secc_doc(samp_vals, sgpts_2010_tb, tb_seg, radius = 0.1, trace = T)
@

%%%%%%
% tables

% summary of wbid characteristics
<<eval = T, echo = F>>=


load(file = 'data/seg_summ.RData')

# rearrange col orders for alphabetical
names(seg_summ) <- c('WCB', 'BB', 'OTB', 'UIRL')
seg_summ <- seg_summ[, order(names(seg_summ))]

# prep table
tab <- seg_summ
nms <- names(tab)
tab <- data.frame(apply(tab, 2, form_fun), stringsAsFactors = F)
tab<- rbind(year = c('2006', '2010', '2009', '2007'), tab)
names(tab) <- nms
rows <- c('Year\\textsuperscript{\\textit{b}}', 'Latitude', 'Longitude', 'Surface area', 'Seagrass area', 'Depth (mean)', 'Depth (max)', 'Secchi (mean)', 'Secchi (se)')

# shorten names
names(tab) <- gsub('BB', 'BB\\\\textsuperscript{\\\\textit{a}}', names(tab))

cap.val <- "Characteristics of coastal segments used to evaluate seagrass \\acl{doc} estimates (see \\cref{fig:seg_all} for spatial distribution).  Year is the date of the seagrass coverage and bathymetric data.  Latitude and longitude are the geographic centers of each segment.  Area and depth values are square kilometers and meters, respectively.  Secchi measurements (m) were obtained from the Florida Department of Environmental Protection's \\acl{IWR} (\\acs{IWR}) database, update number 40.  Secchi mean and standard errors are based on all observations within the ten years preceding each seagrass survey."

foot.val <- '\\footnotesize \\textsuperscript{\\textit{a}} BB: Big Bend, OTB: Old Tampa Bay, UIRL: Upper Indian R. Lagoon, WCB: Western Choctawhatchee Bay\\\\\\textsuperscript{\\textit{b}} Seagrass coverage data sources, see methods for bathymetry data sources:\\scriptsize\\\\BB: \\url{http://atoll.floridamarine.org/Data/metadata/SDE_Current/seagrass_bigbend_2006_poly.htm}\\\\OTB: \\url{http://www.swfwmd.state.fl.us/data/gis/layer_library/category/swim}\\\\UIRL: \\url{http://www.sjrwmd.com/gisdevelopment/docs/themes.html}\\\\WCB: \\url{http://atoll.floridamarine.org/data/metadata/SDE_Current/seagrass_chotawhatchee_2007_poly.htm}'

latex( 
  tab,
  file = '',
  rowlabel = '',
  caption = cap.val,
  caption.loc = 'top',
  insert.bottom = foot.val, 
  rowname = rows,
  label = 'tab:seg_summ'
  )

@

% comparisons with segment wide ests
<<eval = T, echo = F>>=


# load data
load(file = 'data/ests_seg.RData')
load(file = 'data/ests_out.RData')

# summarize spatial ests for grid points
ests_summ <- select(ests_out, -optional, -confint, -lower_max) %>% 
  gather('var', 'val', z_cmin:z_cmax) %>% 
  group_by(seg, var) %>% 
  nest %>% 
  mutate(summs = map(data, function(x){
    
    # model to get average and ste that account for spatial corr
    mod <- gls(val ~ 1, correlation = corGaus(form = ~ long + lat, nugget = TRUE), data = x) %>% 
      summary %>% 
      .$tTable
    
    # get all estimates
    est <- mod[1]
    est_ste <- mod[2]
    est_std <- sd(x$val, na.rm = TRUE)
    est_min <- min(x$val, na.rm = TRUE)
    est_max <- max(x$val, na.rm = TRUE)
    
    # output
    data.frame(est = est, est_ste = est_ste, est_std = est_std, est_min = est_min, est_max = est_max)
    
    })
  ) %>% 
  select(-data) %>% 
  unnest

# merge with segment wide ests
tonm <- grep('min$|med$|max$', names(ests_seg))
names(ests_seg)[tonm] <- paste0(names(ests_seg)[tonm], '_estwide')
to_tab <- select(ests_seg, -long, -lat) %>% 
  gather('var', 'val', -seg) %>% 
  mutate(var = gsub('z_', '', var)) %>% 
  separate(var, c('var', 'typ'), sep = '_') %>% 
  mutate(var = paste0('z_', var)) %>% 
  spread(typ, val) %>% 
  left_join(ests_summ, by = c('seg', 'var')) %>% 
  mutate(
    seg = factor(as.character(seg), 
      levels = c('820', '902', '1502', '303'), 
      labels = c('BB', 'OTB', 'UIRL', 'WCB')
      ), 
    var = factor(var, 
      levels = c('z_cmin', 'z_cmed', 'z_cmax'), 
      labels = c('$Z_{c,\\,min}$', '$Z_{c,\\,med}$', '$Z_{c,\\,max}$')
      )
  ) %>% 
  arrange(seg, var)

names(to_tab) <- c('Segment', 'Estimate', 'Whole Segment', 'Pred. Int. (+/-)', 'Mean', 'St. Err.', 'St. Dev.', 'Min', 'Max')

# prep table
estimate <- to_tab$Estimate
segs <- levels(to_tab$Segment)
nms <- names(to_tab)[-c(1, 2)]
tab <- to_tab[, !names(to_tab) %in% c('Segment', 'Estimate')]

tab <- data.frame(apply(tab, 2, form_fun), stringsAsFactors = F)
names(tab) <- nms

foot.val<-'\\textsuperscript{\\textit{a}}\\footnotesize BB: Big Bend, OTB: Old Tampa Bay, UIRL: Upper Indian River Lagoon, WCB: Western Choctawhatchee Bay.' 

cap.val <- "Summary of seagrass depth estimates (m) for each segment in \\cref{fig:all_ests}.  Whole segment estimates and prediction intervals were obtained from a single point estimate that included all seagrass depth data for the segment. Mean, standard error, standard deviation, minimum, and maximum values are for multiple grid points within each segment in \\cref{fig:all_ests}.  Mean and standard error estimates were from intercept-only models that included Gaussian correlation structures to account for spatial dependencies between points."

latex(
  tab,
  file = '',
  rowlabel = '{\\bf Segment\\textsuperscript{\\textit{a}}}',
  caption = cap.val,
  dcolumn = T,
  caption.loc = 'top',
  rgroup = segs,
  n.rgroup = rep(3,4),
  insert.bottom = foot.val,
  rowname = estimate,
  label = 'tab:est_summ'
  )

@

% summary of light requirements analysis, med depth ests
<<eval = T, echo = F>>=

##
# load data

# load results from figure chunks
data(tb_light)
data(irl_light)
data(choc_light)

##
# prep data

# add bay column, select relevant columns
choc_light <- mutate(choc_light, bay = 'Choctawhatchee Bay') %>% 
  select(bay, seg, z_c_all, light)
irl_light <- mutate(irl_light, bay = 'Indian River Lagoon')%>% 
  select(bay, seg, z_c_all, light) %>% 
  filter(!seg %in% 'LSL')
tb_light <- mutate(tb_light, bay = 'Tampa Bay')%>% 
  select(bay, seg, z_c_all, light)

# summarize
all_light <- rbind(choc_light, irl_light, tb_light) %>% 
  group_by(bay, seg) %>% 
  summarize(
    n_locs = length(seg), 
    mean_z_cmed = mean(z_c_all), 
    se_z_cmed = sd(z_c_all),
    min_z_cmed = min(z_c_all),
    max_z_cmed = max(z_c_all),
    mean_light = mean(light),
    se_light = sd(light),
    min_light = min(light),
    max_light = max(light)
    )

# means need to be from mixed models
data(tb_light)
data(choc_light)
data(irl_light)

irl_light <- filter(irl_light, !seg %in% 'LSL')

tb_light$seg <- factor(tb_light$seg)
choc_light$seg <- factor(choc_light$seg)
irl_light$seg <- factor(irl_light$seg)

zc1 <- lme(z_c_all ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data = tb_light)
zc2 <- lme(z_c_all ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data = choc_light)
zc3 <- lme(z_c_all ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data =irl_light)

lm1 <- lme(light ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data = tb_light)
lm2 <- lme(light ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data = choc_light)
lm3 <- lme(light ~ 0 + seg, random = ~ 1 | seg,
  correlation = corGaus(form = ~ Latitude + Longitude | seg, nugget = TRUE), 
  data =irl_light)

avezc <- lapply(list(zc2, zc3, zc1), function(x) x$coefficients$fixed) %>% 
  unlist
sezc <- lapply(list(zc2, zc3, zc1), function(x) summary(x)$tTable[, 2]) %>% 
  unlist
avelight <- lapply(list(lm2, lm3, lm1), function(x) x$coefficients$fixed) %>% 
  unlist 
selight <- lapply(list(lm2, lm3, lm1), function(x) summary(x)$tTable[, 2]) %>% 
  unlist

all_light$mean_z_cmed <- avezc
all_light$se_z_cmed <- sezc
all_light$mean_light <- avelight
all_light$se_light <- selight

save(all_light, file = 'data/all_light.RData')

# load data
data(all_light)

# prep for table
tab <- data.frame(all_light)
# tab <- tab[, !grepl('_light$', names(tab))]
rows <- tab[, 2]
rowgrps <- table(tab[, 1])
tab <- tab[, -c(1:2)]
tab[, 2:9] <- formtab_fun(tab[, 2:9], 1, 1, 1)
nms <- names(tab) # this is fucked
ncoltab <- ncol(tab)
nrowtab <- nrow(tab)
tab <- unlist(tab)
tab[grepl('NaN$', tab)] <-  ' '
tab <- matrix(tab, nrow = nrowtab, ncol = ncoltab)
tab <- data.frame(tab)
names(tab) <- nms

# add sig letters to mean_z_cmed from gls comparisons
avals <- c(2, 4:10, 14)
bvals <- c(3, 13)
abvals <- c(1, 11:12)
tab$mean_z_cmed <- as.character(tab$mean_z_cmed)
tab$mean_z_cmed[avals] <- paste0(tab$mean_z_cmed[avals], '\\textsuperscript{a}')
tab$mean_z_cmed[bvals] <- paste0(tab$mean_z_cmed[bvals], '\\textsuperscript{b}')
tab$mean_z_cmed[abvals] <- paste0(tab$mean_z_cmed[abvals], '\\textsuperscript{ab}')

cap.val<-'Summary of median depth of colonization ($Z_{c,\\,med}$, m) and light requirements (\\%) for all bay segments of Choctawhatchee Bay, Indian River Lagoon, and Tampa Bay.  Superscripts for mean $Z_{c,\\,med}$ denote significant differences within each bay. See \\cref{fig:light_choc,fig:light_tb,fig:light_irl} for spatial distribution of the results.'

foot.val<-'\\textsuperscript{\\textit{a}}\\footnotesize CCB: Central Choctawhatchee Bay, ECB: Eastern Choctawhatchee Bay, WCB: Western Choctawhatchee Bay, BR: Banana R., LCIRL: Lower Central Indian R. Lagoon, LIRL: Lower Indian R. Lagoon, LML: Lower Mosquito Lagoon, UCIRL: Upper Central Indian R. Lagoon, UIRL: Upper Indian R. Lagoon, UML: Upper Mosquito Lagoon, HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.' 
col_heads <- c('$n$', rep(c('Mean', 'St. Err.', 'Min', 'Max'), 2))

latex( 
  tab,
  file = '',
  rowlabel = 'Segment\\textsuperscript{\\textit{a}}',
  insert.bottom = foot.val,
  caption = cap.val,
  colheads = col_heads,
  cgroup = c('', '$\\mathbf Z_{c,\\,med}$', '{\\bf \\% light}'), 
  n.cgroup = c(1, 4, 4),
  caption.loc = 'top',
  rowname = rows,
  rgroup = names(rowgrps),
  n.rgroup = rowgrps,
  size = 'small'
  )
@

\clearpage

%%%%%%
% figures

% example of buffer points for depth of col
<<buff_ex, cache = T, fig = F, echo = F, eval = T, message = F, results = 'hide', include = F>>=
########

# reset digits
options(digits = 4)

# load data, buff_ex_dat was created from various shapefiles
data(buff_ex_dat)
seg <- buff_ex_dat[['seg']] # 820 segment polygon
state <- buff_ex_dat[['state']] # florida state polygon
sgpoly <- buff_ex_dat[['sgpoly']] # 820 segment seagrass polygon
sgrass <- buff_ex_dat[['sgrass']] # 820 segment seagrass depth point
depths <- buff_ex_dat[['depths']] # 820 segment bathymetry dem, for contour lines
rm('buff_ex_dat')

# get a subsample of seagrass depth points for plotting
set.seed(4321)

est_pts <- grid_est(seg, spacing = 0.02)
sgrass <- sgrass[sample(1:length(sgrass), 1000), ]
test_pt <- est_pts[27, ]
buff_pts <- buff_ext(sgrass, test_pt, buff = 0.04)

# format buff_pts and sgrass for plotting
buff_pts <- data.frame(buff_pts)
levels(buff_pts$Seagrass) <- c('Seagrass present', 'Seagrass present', 'Seagrass absent')
buff_pts$Seagrass <- as.character(buff_pts$Seagrass)
sgrass <- data.frame(sgrass)
levels(sgrass$Seagrass) <- c('Seagrass present', 'Seagrass present', 'Seagrass absent')
sgrass$Seagrass <- as.character(sgrass$Seagrass)

# segment wide est for zcmax (all cats) for 820 from Hagy is 3.855
# get contour lines from bathymetry layer, one for whole segment and one for limit
to_cont <- seq(1, 15, by = 2)
im <- as.image.SpatialGridDataFrame(depths)
conts <- contourLines(im, levels = -1 * to_cont)
conts <- ContourLines2SLDF(conts)
zc_conts <- contourLines(im, levels = -3.855)
zc_conts <- ContourLines2SLDF(zc_conts)

# for labelling contours
clevs <- data.frame(conts) %>% 
  mutate(id = row.names(.))
cont_labs <- fortify(conts) %>% 
  group_by(id) %>% 
  filter(lat == quantile(lat, 0.5, type = 1)) %>% 
  left_join(., clevs, by = 'id') %>% 
  mutate(level = -1 * as.numeric(as.character(level)))
w <- 0.015
h <- 0.015

xlims <- c(-83.68, -83.35)
ylims <- c(29.4, 29.8)

# subfig labels
sublabs <- data.frame(long = -83.375, lat = 29.78, labs = c('a', 'b', 'c'))

# seagrass and depth contours
p1 <- ggplot(state, aes(long, lat, group = group)) + 
  geom_polygon(fill = 'lightgrey') +
  geom_path(data = conts, 
    aes(group = group, linetype = 'dashed')
    ) + 
  geom_rect(data = cont_labs, aes(xmin = long - w/2, xmax = long + w/2, 
    ymin = lat - h/2, ymax = lat + h/2), fill = 'white') +
  geom_text(data = cont_labs, 
    aes(group = group, label = level), size = 3
    ) + 
  geom_polygon(data = seg, fill = alpha('white', 0), col = 'black', aes(size = 'Segment polygon')) + 
  geom_polygon(data = sgpoly, aes(group = group, fill = 'Seagrass coverage'), 
    alpha = 0.7) + 
  geom_polygon(data = state, aes(group = group), 
    fill = 'grey') + 
  geom_path(data = zc_conts, 
    aes(group = group, colour = 'Estimated depth\nlimit for segment'), 
    size = 2
    ) +
  scale_fill_manual(values = 'royalblue') + 
  scale_colour_manual(
    values = 'red'
    ) +
  scale_size_manual('', values = 2) +
  scale_linetype_manual(labels = '2 m depth contours', values = 'dashed') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  coord_map(
    xlim = xlims,
    ylim = ylims
  ) +
  theme(axis.text = element_text(size = 10),
    axis.title = element_text(size = 20), 
    legend.text = element_text(size = 20),
    legend.title = element_blank(), 
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  ) + 
  guides(fill = guide_legend(order = 1), 
    linetype = guide_legend(order = 2), 
    colour = guide_legend(order = 3)
  ) + 
  geom_text(data = sublabs[1, ], aes(x = long, y = lat, label = labs, group = NULL), size = 8) +
  geom_point(aes(x = -83.4, y = 29.673), pch = 4, size = 4)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none')

p2 <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black', size = 2) +
  geom_polygon(data = state, aes(group = group), fill = 'lightgrey') + 
  xlab('Longitude') +
  ylab('Latitude') +
  geom_point(
    data = data.frame(sgrass), 
    aes(x = coords_x1, y = coords_x2, shape = Seagrass), col = 'royalblue'
    ) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), size = 3, pch = 21, col = 'black', bg = 'white'
  ) +  
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), size = 33, pch = 1, colour = 'grey60'
  ) +
  scale_shape_manual('', values = c(2, 16)) +
  coord_equal() +
  coord_map(
    xlim = xlims,
    ylim = ylims
    ) + 
  theme_classic() +
  theme(axis.text = element_text(size = 10),
    legend.text = element_text(size = 20),
    axis.title = element_text(size = 20), 
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  geom_text(data = sublabs[2, ], aes(x = long, y = lat, label = labs, group = NULL), size = 8)

p2leg <- g_legend(p2)
p2 <- p2 + theme(legend.position = 'none')

p3 <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black', size = 2) +
  geom_polygon(data = state, aes(group = group), fill = 'lightgrey') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  coord_map(
    xlim = xlims,
    ylim = ylims
    ) +
  geom_point(
    data = buff_pts,
    aes(coords.x1, coords.x2, pch = Seagrass), 
    colour = 'royalblue'
  ) + 
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), colour = 'black', bg = 'white', size = 3, pch = 21
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2), colour = 'red', size = 5, pch = 16
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2), size = 33, pch = 1, colour = 'grey60'
  ) +
  scale_shape_manual('', values = c(2, 16)) +
  theme(axis.text = element_text(size = 10),
    legend.text = element_text(size = 20), 
    axis.title = element_text(size = 20), 
    legend.position = 'none', 
    axis.line.x = element_line(), 
    axis.line.y = element_line())  + 
  geom_text(data = sublabs[3, ], aes(x = long, y = lat, label = labs, group = NULL), size = 8) + 
  scalebar(location = 'bottomleft', y.min = 29.42, y.max = 29.5, x.min = -83.66, x.max = -83.45, 
    dist=5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 4, height = 0.05)

pleg <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  scale_x_continuous(limits = xlims) +
  scale_y_continuous(limits = ylims) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2, colour = 'grid', size = 'grid', pch = 'grid')
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2, colour = 'test', size = 'test', pch = 'test')
  ) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2, size = 'rad', pch = 'rad', colour = 'rad')
  )  +
  scale_colour_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c('black', 'red', 'grey60')) +
  scale_size_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c(3, 4, 10)) +
  scale_shape_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c(1, 16, 1)) +
theme(axis.text = element_text(size = 20),
  legend.text = element_text(size = 20),
  axis.title = element_text(size = 20)
  )

pleg <- g_legend(pleg)

pdf('figs/Fig1.pdf', height = 12, width = 9.5, family = 'serif')
grid.arrange(
  arrangeGrob(p1, p2, ncol = 2),
  arrangeGrob( p3, 
    arrangeGrob(p1leg, p2leg, pleg, heights = c(1, 0.7, 0.7), ncol = 1), 
    ncol = 2
    ), 
  ncol = 1
)
dev.off()
   
options(digits = 2)
@

% example of buffer points for depth of col
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{figs/Fig1.pdf}
\caption{Examples of data and grid locations for estimating seagrass depth of colonization for a region of the Big Bend, Florida.  Subfigure a shows the seagrass coverage and depth contours at 2 meter intervals, including the whole segment estimate for depth of colonization and location of the outflow of the Steinhatchee River (x). Subfigure b shows a grid of sampling locations with sampling radii for estimating \ac{doc} and seagrass depth points derived from bathymetry and seagrass coverage layers.  Subfigure c shows an example of sampled seagrass depth points for a test location.}
\label{fig:buff_ex}
\end{figure}

% example of depth of col ests for wbid - big bend 820
\begin{figure}
\centerline{\includegraphics[width = \textwidth]{figs/Fig2.pdf}}
\caption{Locations and seagrass coverage of estuary segments used to evaluate \acl{doc} estimates.  Seagrass coverage layers are from 2006 (BB: Big Bend), 2010 (OTB: Old Tampa Bay), 2009 (UIRL: Upper Indian R. Lagoon), and 2007 (WCB: Western Choctawhatchee Bay). SR: Steinhatchee River outflow, MI: Merritt Island National Wildlife Refuge.}
\label{fig:seg_all}
\end{figure}

% example of estimating seagrass depth of colonization

% example of depth of col ests for wbid - big bend 820
\begin{figure}
\centering
\includegraphics[width=0.85\textwidth]{figs/Fig3.pdf}
\caption{Methods for estimating seagrass depth of colonization using sampled seagrass depth points around a single location. Three depth estimates ($Z_{c,\,min}$, $Z_{c,\,med}$, $Z_{c,\,max}$) are based on a linear curve through the inflection point of a logistic growth curve .  The logistic curve is defined by the parameters $\alpha$, $\beta$, and $\gamma$ and describes the decrease in the proportion of sample points with seagrass as a function of depth below mean tide leavel (MTL).  The top figure shows the estimation method when the linear curve intercepts $\alpha$ at depth greater than zero and the bottom figure shows the estimation method when the linear curve intercepts $\alpha$ at depth less than zero.}
\label{fig:est_ex}
\end{figure}

% grid examples for each segment
<<all_ests, echo = F, cache = T, results = 'hide', eval = T>>=

options(digits = 2)

##
# load data
# ests out created in chunk for table 'tab:est_summ'
data(shps)
data(ests_out)

##
# make plots

# colors and pt_sz
col_vals <- c('blue', 'lightblue', 'yellow', 'brown')
pt_sz <- 2
  
# segments for plotting
all_segs <- shps[grepl('^seg_', names(shps))]
all_segs <- lapply(all_segs, fortify)
all_segs <- do.call('rbind', all_segs)
all_segs$group <- gsub('^seg_|\\.shp\\.[0-9]*$', '', row.names(all_segs))
all_segs$group <- factor(all_segs$group, levels = c('820', '902', '1502', '303'), 
  labels = c('BB', 'OTB', 'UIRL', 'WCB'))
all_segs$group <- as.character(all_segs$group)
levs <- sort(unique(all_segs$group))

levels(ests_out$seg) <- c('WCB', 'BB', 'OTB', 'UIRL')

scbr <- list(
  c(29.44, 29.52, -83.63, -83.45, 5, 0.05),
  c(27.85, 27.92, -82.8, -82.65, 5, 0.05),
  c(28.38, 28.5, -80.85, -80.725, 5, 0.05),
  c(30.39, 30.44, -86.64, -86.59, 2.5, 0.05)
)

# assign plots by segment and doc est
for(i in 1:length(levs)){
  
  # subset segment shapefiles and ests by segment
  seg_sub <- all_segs[all_segs$group %in% levs[i], ]
  est_sub <- ests_out[ests_out$seg %in% levs[i], ]
  
  # for scale bar
  sc <- scbr[[i]]
  
  # label
  lab <- unique(est_sub$seg) %>% 
    as.character
  
  # points to plot
  pt_plo <- data.frame(est_sub[, c('seg', 'long', 'lat', 'z_cmax')])
  
  # segment base plot
  p_seg <- ggplot(seg_sub, aes(x = long, y = lat)) +
    geom_polygon(fill = 'lightgrey', colour = 'black') + 
    coord_fixed() +
    theme_classic() +
    theme(axis.title = element_blank(), axis.text = element_text(size = 6), 
      axis.text.x = element_text(angle = 90, vjust = 0.5),
      plot.margin=unit(c(0, 0, 0, 0), "cm"), 
      axis.line.x = element_line(), axis.line.y = element_line()) + 
    scale_x_continuous(labels = fmt()) + 
    scale_y_continuous(labels = fmt())
  
  # z_cmax
  pa <- p_seg +
    geom_point(data = pt_plo, aes(x = long, y = lat, colour = z_cmax), 
      size = pt_sz, alpha = 0.8) +
    scale_colour_gradientn(colours = col_vals) +
    theme(legend.title = element_blank()) + 
    scalebar(location = 'bottomleft', y.min = sc[1], y.max = sc[2], x.min = sc[3], x.max = sc[4], 
      dist = sc[5], dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = sc[6]) + 
    ggtitle(lab)

  # legends
  paleg <- g_legend(pa)
  pa <- pa + theme(legend.position = 'none')

  # assign to global
  assign(paste0('pa', i), pa)
  assign(paste0('paleg', i), paleg)

  }

# labels
# lab1 <- expression(italic(Z ['c, max']), '(m)')

# arrange all as grob
grobwidths <- c(1, 0.3)

pdf('figs/Fig4.pdf', height = 7, width = 7, family = 'serif')
grid.arrange(
  arrangeGrob(pa1, paleg1, ncol = 2, widths = grobwidths),
  arrangeGrob(pa2, paleg2, ncol = 2, widths = grobwidths),
  arrangeGrob(pa3, paleg3, ncol = 2, widths = grobwidths),
  arrangeGrob(pa4, paleg4, ncol = 2, widths = grobwidths),
  ncol = 2, widths = c(0.85, 1)
)
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/Fig4.pdf}
\caption{Spatially-resolved estimates of maximum seagrass depth of colonization (m) for four coastal segments of Florida.  Estimates are assigned to grid locations for each segment, where grid spacing was fixed at 0.01 decimal degrees.  Radii for sampling seagrass bathymetric data around each grid location were fixed at 0.02 decimal degrees. BB: Big Bend, OTB: Old Tampa Bay, UIRL: Upper Indian R. Lagoon, WCB: Western Choctawhatchee Bay.}
\label{fig:all_ests}
\end{figure}

% satellite estimates of water clarity for choc bay
<<kd_choc, echo = F, eval = T, cache = T, results = 'hide'>>=
options(digits = 7) 

# load data
data(choc_seg)
data(choc_sats_crc)

# clip sats_melt

sats_melt <- reshape2::melt(choc_sats_crc[['sats_all']], id.var = c('lat', 'lon'))

# color ramp
cols <- c('blue', 'lightblue', 'yellow', 'brown')

# prep data

to_plo <- sats_melt
to_plo$variable <- factor(to_plo$variable, labels = c('Average', seq(2003, 2007)))
seg_plo <- fortify(choc_seg)

# get average only
to_plo <- filter(to_plo, variable == 'Average')

# leg lab
leg_lab <- expression(paste(italic(K [d]), ' (', m^-1, ')')) 

# make plot
p <- ggplot(data = seg_plo) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = colors()[245]) +
  geom_tile(data = subset(to_plo, !is.na(value)), 
    aes(x = lon, y = lat, fill = value, colour = value)
  ) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = NA) +
  coord_equal() +
  scale_colour_gradientn(leg_lab, colours = cols) +
  scale_fill_gradientn(leg_lab, colours = cols) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.title.x = element_blank(), 
    axis.title.y = element_blank(),
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8),
    legend.position = 'top', 
    axis.line.x = element_line(), 
    axis.line.y = element_line(),
    legend.text = element_text(size = 6)
    ) + 
  scalebar(location = 'bottomleft', y.min = 30.375, y.max = 30.44, x.min = -86.62, x.max = -86.5, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

pdf('figs/Fig5.pdf', height = 3, width = 5, family = 'serif')
p
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = \textwidth]{figs/Fig5.pdf}
\caption{Satellite estimated light attenuation for Choctawhatchee Bay as an average of all years from 2003 to 2007.  See \cref{fig:light_choc} for segment identification.}
\label{fig:kd_choc}
\end{figure}

% satellite estimates of water clarity for Tampa Bay
<<kd_tb, echo = F, eval = T, cache = T, results = 'hide'>>=
options(digits = 7) 

# load data
data(tb_seg)
data(tb_sats)
sats_melt <- reshape2::melt(tb_sats[['sats_all']], id.var = c('lat', 'lon'))

# color ramp
cols <- c('blue', 'lightblue', 'yellow', 'brown')

# prep data
to_plo <- sats_melt
to_plo$variable <- factor(to_plo$variable, labels = c('Average', seq(2003, 2010)))
seg_plo <- fortify(tb_seg)

# leg lab
leg_lab <- expression(paste(italic(K [d]), ' (', m^-1, ')')) 

# get average only, convert to kd
to_plo <- filter(to_plo, variable == 'Average') %>% 
  mutate(value = 1.7/value) %>% 
  filter(value <= 1.4)
  
# make plot
p <- ggplot(data = seg_plo) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = colors()[245]) +
  geom_tile(data = subset(to_plo, !is.na(value)), 
    aes(x = lon, y = lat, fill = value, colour = value)
  ) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = NA) +
  coord_equal() +
  scale_colour_gradientn(leg_lab, colours = cols) +
  scale_fill_gradientn(leg_lab, colours = cols) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.title.x = element_blank(), 
    axis.title.y = element_blank(),
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8), 
    legend.position = 'top', 
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  scalebar(location = 'bottomright', y.min = 27.54, y.max = 27.65, x.min = -82.58, x.max = -82.41, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.05)

pdf('figs/Fig6.pdf', height = 5.5, width = 5, family = 'serif')
p
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.7\textwidth]{figs/Fig6.pdf}
\caption{Satellite estimated water clarity for Tampa Bay as an average of all years from 2006 to 2010. See \cref{fig:light_tb} for segment identification.}
\label{fig:clarity_tb}
\end{figure}

% estimated light requirements for Choctawhatchee Bay, z_cmed
<<light_choc, echo = F, eval = T, cache = T, include = FALSE, results = 'hide'>>=

library(grid)

# reset digits to default
options(digits = 7)

data(choc_light)
data(choc_seg)

# centroids for labels
labs <- data.frame(rgeos::gCentroid(choc_seg, byid = T))
labs$seg <- choc_seg$seg

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(choc_light)
dat$seg <- factor(dat$seg, levels = c('WCB', 'CCB', 'ECB'))
dat <- dat[dat$light < 80, ]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmed
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmed
p1 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8, size = 3) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, med']) ~ (m)), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, med']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) + 
  scalebar(location = 'bottomleft', y.min = 30.375, y.max = 30.44, x.min = -86.64, x.max = -86.5, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none', 
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmed
# reorder seg labels
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab(bquote(italic('Z' ['c, med']))) +
  theme_classic() +
  theme(axis.title.x = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  )

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8, size = 3) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(
  legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('Light requirements (% SI)') +
  theme_classic() +
  theme(axis.title.x = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  )

# for filler
blankPanel <- grid.rect(gp=gpar(col="white"))

# align
# Get the widths
pA <- ggplot_gtable(ggplot_build(p1))
pB <- ggplot_gtable(ggplot_build(p2))
pC <- ggplot_gtable(ggplot_build(p3))
pD <- ggplot_gtable(ggplot_build(p4))
maxWidth = grid::unit.pmax(pA$widths[2:3], pB$widths[2:3], pD$widths[2:3], pD$widths[2:3])

# Set the widths
pA$widths[2:3] <- maxWidth
pB$widths[2:3] <- maxWidth
pC$widths[2:3] <- maxWidth
pD$widths[2:3] <- maxWidth

pdf('figs/Fig7.pdf', height = 8, width = 8, family = 'serif')
grid.arrange(pA, p1leg, pB, blankPanel, pC, p3leg, pD, blankPanel, 
  ncol = 2, nrow = 4, 
  widths = c(1, 0.2), heights = c(1, 0.7, 1, 0.7))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/Fig7.pdf}
\caption{Estimated median depths of seagrass colonization and light requirements for multiple locations in Choctawhatchee Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.04 decimal degrees.  Estimates are also summarized by bay segment as boxplots where the dimensions are the 25\textsuperscript{th} percentile, median, and 75\textsuperscript{th} percentile.  Whiskers extend to the 5\textsuperscript{th} and 95\textsuperscript{th} percentiles with outliers beyond. CCB: Central Choctawhatchee Bay, ECB: East Choctawhatchee Bay, WCB: West Choctawhatchee Bay.}
\label{fig:light_choc}
\end{figure}

% estimated light requirements for Tampa Bay, z_cmed
<<light_tb, echo = F, eval = T, cache = T, results = 'hide'>>=

# reset digits to default
options(digits = 7)

data(tb_light)
data(tb_seg)
data(sgbuff_2010_tb)

# mask tb doc and light ests by 1km buffer of seagrass
coordinates(tb_light) = ~Longitude+Latitude
tmp <- tb_light  %over% sgbuff_2010_tb %>% 
  is.na(.) %>% 
  !.
tb_light <- data.frame(tb_light)[tmp, ]

# centroids for labels
labs <- data.frame(rgeos::gCentroid(tb_seg, byid = T))
labs$seg <- c('HB', 'LTB', 'MTB', 'OTB')

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(tb_light)
# outs <- quantile(dat$light, c(0.05, 0.95))
# dat <- dat[dat$light > outs[1] & dat$light < outs[2],]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmed
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmed
p1 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, med']) ~ (m)), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, med']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) + 
  scalebar(location = 'bottomright', y.min = 27.53, y.max = 27.62, x.min = -82.58, x.max = -82.41, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmed
# reorder seg labels
segs <- c('LTB', 'MTB', 'HB', 'OTB')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") + 
  ylab(bquote(italic('Z' ['c, med']))) +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  ) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

pdf('figs/Fig8.pdf', height = 7.5, width = 7, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/Fig8.pdf}
\caption{Estimated median depths of seagrass colonization and light requirements for multiple locations in Tampa Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.1 decimal degrees.  Estimates are also summarized by bay segment as boxplots as in \cref{fig:light_choc}. HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:light_tb}
\end{figure}

% estimated light requirements for Indian River Lagoon, zcmed
<<light_irl, echo = F, eval = T, cache = T, results = 'hide'>>=

# reset digits to default
options(digits = 7)

data(irl_light)

data(irl_seg)

# centroids for labels, offset
labs <- data.frame(rgeos::gCentroid(irl_seg, byid = T, id = irl_seg$seg))
labs$x <- labs$x - 0.3
labs$seg <- rownames(labs)
labs <- labs[!labs$seg %in% c('LSL', 'LHR'), ]

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(irl_light) %>% 
  filter(!seg %in% 'LSL')

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmed
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmed
p1 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, med']) ~ (m)), range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, med']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) + 
  scalebar(location = 'bottomleft', y.min = 27.16, y.max = 27.5, x.min = -81.2, x.max = -80, 
    dist = 30, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmed
# reorder seg labels
segs <- c('LSL', 'LIRL', 'LCIRL', 'UCIRL', 'BR', 'UIRL', 'LML', 'UML')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") + 
  ylab(bquote(italic('Z' ['c, med']))) +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

pdf('figs/Fig9.pdf', height = 8.5, width = 6.5, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()

options(digits = 1)
@
\begin{figure}
\centering
\includegraphics[width = 0.8\textwidth]{figs/Fig9.pdf}
\caption{Estimated median depths of seagrass colonization and light requirements for multiple locations in Indian River Lagoon, Florida.  Map locations are georeferenced observations of water clarity in the Florida \acl{IWR} database, update 40.  Estimates are also summarized by bay segment as boxplots as in \cref{fig:light_choc}. Light requirements are based on averaged secchi values within ten years of the seagrass coverage data and estimated maximum depth of colonization using a radius of 0.15 decimal degrees for each secchi location to sample seagrass depth points. BR: Banana R., LCIRL: Lower Central Indian R. Lagoon, LIRL: Lower Indian R. Lagoon, LML: Lower Mosquito Lagoon, LSL: Lower St. Lucie, UCIRL: Upper Central Indian R. Lagoon, UIRL: Upper Indian R. Lagoon, UML: Upper Mosquito Lagoon.}
\label{fig:light_irl}
\end{figure}

% tb light requirement changes 1988 - 2010
<<tb_ts, echo = F, eval = F, cache = T, results = 'hide'>>=
# secchi and satellite light ests, all years
data(tb_light_allsec)

sec <- reshape2::melt(tb_light_allsec, id.vars = names(tb_light_allsec[[1]])) %>% 
  rename(yr = L1) %>% 
  mutate(kd = 1.7/SD)

# complete year locs
yrloc <- select(sec, yr, Longitude, Latitude) %>% 
  unite('lon_lat', Longitude, Latitude, remove = F) %>% 
  complete(lon_lat, yr) %>% 
  arrange(yr)

# remove locations that aren't common between all years
torm <- unique(yrloc$lon_lat[is.na(yrloc$Longitude)])
sec <- unite(sec, 'lon_lat', Longitude, Latitude, remove = F) %>% 
  filter(!lon_lat %in% torm) %>% 
  rename(Segment = seg)

# segment colors
cols <- rev(RColorBrewer::brewer.pal(11, 'RdYlBu')[c(2, 4, 8, 10)])

# get medians by segment/year
summs <- group_by(sec, Segment, yr) %>% 
  summarise(
    kd = median(kd), 
    z_c_all = median(z_c_all), 
    light = median(light)
  )

# si curves
  
kd <- seq(0.35, 1.5, length = 100)
z_c_all <- seq(0.7, 1.4, length = 100)
ests <- expand.grid(kd, z_c_all)
si <- 100 * exp((-ests[, 1]) * ests[, 2])

dat <- data.frame(ests, si)
names(dat) <- c('kd', 'z_c_all', 'si')

# labels
labs <- summs %>% 
  mutate(
    yr = ifelse(!yr %in% c('1988', '2014'), '', yr)
    )
ylab <- expression(paste(italic(Z ['c, med']), ' (m)'))
xlab <- expression(paste(italic(K [d]), ' (', m^-1, ')')) 

# time paths
p1 <- ggplot() + 
  stat_contour(data=dat, aes(x = kd, y = z_c_all, z = si, colour=..level..)) +
  geom_path(data = summs, aes(x = kd, y = z_c_all, group = Segment), size = 1) +
  geom_point(data = summs, aes(x = kd, y = z_c_all, fill = Segment), colour = 'black', size = 3, pch = 21) + 
  geom_label_repel(data = labs, aes(x = kd, y = z_c_all, label = yr),
    size = 3, point.padding = unit(0.6, "lines"), label.padding = unit(0.1, "lines"),
    segment.size = 0.4) +
  scale_y_continuous(ylab) +
  scale_x_continuous(xlab) + 
  scale_fill_manual(values = cols) + 
  facet_wrap(~Segment, scales = 'free') + 
  scale_colour_gradient(low = 'darkgrey', high = 'darkgrey') + 
  coord_cartesian(xlim = c(0.37, 1.49), ylim = c(0.67, 1.4)) +
  theme_bw() + 
  theme(
    legend.position = 'none',
    strip.background = element_blank(), 
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank()
    )
p1 <- direct.label(p1, list('bottom.pieces', cex = 0.7))

# boxplots
p2 <- ggplot(sec, aes(x = factor(yr), y = light, fill = Segment)) +
  geom_boxplot(outlier.size = 1, lwd = 0.4, width = 0.6) +
  theme_bw() + 
  theme(
    legend.position = 'top', 
    axis.title.x = element_blank()
    ) + 
  scale_fill_manual(values = cols) + 
  scale_y_continuous('Light requirements (% SI)')

# align
pA <- ggplot_gtable(ggplot_build(p1))
pB <- ggplot_gtable(ggplot_build(p2))
maxWidth = grid::unit.pmax(pA$widths[2:3], pB$widths[2:3])

# Set the widths
pA$widths[2:3] <- maxWidth
pB$widths[2:3] <- maxWidth

pdf('figs/Fig10.pdf', height = 7, width = 6.5, family = 'serif')
grid.arrange(
  arrangeGrob(pA, pB, ncol = 1, heights = c(1.8, 1))
)
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = \textwidth]{figs/Fig10.pdf}
\caption{Summary of light requirements of seagrasses in segments of Tampa Bay. Estimates are based on Secchi observations at routine monitoring stations and median depth of colonization estimates from coverage maps at approximate biennial intervals from 1988 to 2014. Median changes of $Z_{c, med}$ (m) and light attenuation in each year are shown as continuous paths in the top plot and boxplot distributions of light requirements are shown in the bottom plot. Contoured light requirements (\% SI) are shown in grey in the top plot. See \cref{fig:tb_ts_locs} for locations of stations in each segment. HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:tb_ts}
\end{figure}
\clearpage

% supplementary material
\beginsupplement

<<echo = F, eval = T, cache = T, results = 'hide'>>=

# reset digits to default
options(digits = 7)

# load data
data(choc_seg)
data(choc_sats_unc)
data(choc_situ)

# color ramp
cols <- c('blue', 'lightblue', 'yellow', 'brown')

seg_plo <- fortify(choc_seg)

# get average only
to_plo <-  choc_sats_unc[, c('lon', 'lat', 'kd_2010')] %>% 
  rename(value = kd_2010)

# leg lab
leg_lab <- expression(paste(italic(K [d]), ' (', m^-1, ')')) 

# make plot
p1 <- ggplot(data = seg_plo) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = colors()[245]) +
  geom_tile(data = subset(to_plo, !is.na(value)), 
    aes(x = lon, y = lat, fill = value, colour = value)
  ) +
  geom_polygon(aes(x = long, y = lat, group = group), 
    colour = 'black', fill = NA) +
  geom_point(data = choc_situ, aes(x = Longitude, y = Latitude), size = 3) + 
  coord_equal() +
  scale_colour_gradientn(leg_lab, colours = cols) +
  scale_fill_gradientn(leg_lab, colours = cols) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.title.x = element_blank(), 
    axis.title.y = element_blank(),
    legend.position = 'top', 
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  scalebar(location = 'bottomleft', y.min = 30.375, y.max = 30.44, x.min = -86.62, x.max = -86.5, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2.5, height = 0.07) + 
  labs(subtitle = expression(paste('(a) Uncorrected satellite estimates and stations for ', italic('in situ'), ' data')))


# sample the raster with in situ data locations
sats_all <- choc_sats_unc
sats_2010 <- sats_all[, c('lon', 'lat', 'kd_2010')]
sat_rast_2010 <- make_rast_fun(sats_2010, 'kd_2010')

samp_dat <- choc_situ
coordinates(samp_dat) <- c('Longitude', 'Latitude')
samp_dat <- raster::extract(sat_rast_2010, samp_dat) %>% 
  data.frame  %>% 
  mutate(
    kPAR = choc_situ$kPAR,
    cumkPAR = choc_situ$cumkPAR,
    layer = kd_2010,
    cumlayer = cumsum(layer)/max(cumsum(layer))
    )
samp_dat <- samp_dat[, !names(samp_dat) %in% 'kd_2010']

# use kd_binomod and kd_backsat to get models for correcting and to implement
# models for transformation
kd_mods <- kd_mod(samp_dat, 'kPAR', 'cumkPAR', 'layer', 'cumlayer')

# an example
p2 <- kd_backsat(kd_mods, samp_dat, xsat = 0.75, plot = T, xrng = c(0, 1.5)) + 
  labs(subtitle = '(b) Example of satellite correction')


# Get the widths
pA <- ggplot_gtable(ggplot_build(p1))
pB <- ggplot_gtable(ggplot_build(p2))
maxWidth = grid::unit.pmax(pA$widths[2:3], pB$widths[2:3])

# Set the widths
pA$widths[2:3] <- maxWidth
pB$widths[2:3] <- maxWidth

pdf('figs/FigS1.pdf', height = 5.5, width = 6, family = 'serif')
grid.arrange(pA, pB, ncol = 1, heights = c(1, 0.75))
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = \textwidth]{figs/FigS1.pdf}
\caption{Uncorrected satellite estimates of light attenuation in Choctawhatchee Bay (a) and example of correction with \textit{in situ} data (b). \textit{In situ} data of light attenuation were estimated as an annual average (2010) for monthly data at the sampling sites labelled as points in (a) (mean depth 7.2 m, minimum 3.5 m).  The corresponding satellite data in the same grid cells were compared to the \textit{in situ} data based on regressions of each dataset with frequency estimates for both.  An example correction is shown in (b) where for any uncorrected satellite estimate (point 4), the corresponding frequency estimate on the regression curve from the satellite data was identified (point 2), matched with the corresponding frequency for the \textit{in situ} data (point 3), and then related to the associated \textit{in situ} light attenuation value (point 4) to yield the corrected satellite estimate.}
\label{fig:satcorr}
\end{figure}

% secchi locations used to track light requirement changes over time
<<tb_ts_locs, echo = F, eval = T, cache = T, results = 'hide'>>=
data(tb_seg)
data(tb_light_allsec)

# EPC routine monitoring stations
stats <- foreign::read.dbf('M:/GIS/tb_sta.dbf') %>% 
  select(sta, Actual_Lat, Actual_Lon) %>% 
  rename(
    StationID = sta, 
    Latitude = Actual_Lat, 
    Longitude = Actual_Lon
  ) %>% 
  mutate(
    StationID = as.character(StationID)
  )
    
# secchi and satellite light ests, all years
sec <- reshape2::melt(tb_light_allsec, id.vars = names(tb_light_allsec[[1]])) %>% 
  rename(yr = L1) %>% 
  mutate(kd = 1.7/SD)

# complete year locs
yrloc <- select(sec, yr, Longitude, Latitude) %>% 
  unite('lon_lat', Longitude, Latitude, remove = F) %>% 
  complete(lon_lat, yr) %>% 
  arrange(yr)

# remove locations that aren't common between all years, get unique stations for plot
torm <- unique(yrloc$lon_lat[is.na(yrloc$Longitude)])
sec <- unite(sec, 'lon_lat', Longitude, Latitude, remove = F) %>% 
  filter(!lon_lat %in% torm) %>% 
  left_join(., stats, by = c('Latitude', 'Longitude')) %>% 
  select(StationID, Latitude, Longitude) %>% 
  unique

# centroids for labels
labs <- data.frame(rgeos::gCentroid(tb_seg, byid = T))
labs$seg <- c('HB', 'LTB', 'MTB', 'OTB')
labs[2, 1] <- -82.67
labs[2, 2] <- 27.65
labs[4, 1] <- -82.64
labs[4, 2] <- 27.935

# map, z_cmed
p1 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = colors()[245], aes(group = group)) +
  geom_text(data = sec, aes(x = Longitude, y = Latitude, label = StationID), 
    size = 3, fontface = 'italic') +
  geom_text(data = labs, aes(label = seg, x = x, y = y), size = 6) +
  theme_classic() +
  theme(
    axis.title.x = element_blank(), 
    axis.title.y = element_blank()
  ) + 
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  scale_y_continuous(labels = fmt())  + 
  scalebar(location = 'bottomright', y.min = 27.53, y.max = 27.62, x.min = -82.58, x.max = -82.41, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

pdf('figs/FigS2.pdf', height = 5.5, width = 5, family = 'serif')
p1
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = 0.7\textwidth]{figs/FigS2.pdf}
\caption{Locations of selected water quality stations monitored by the Hillsborough County Environmental Protection Commission (TBEP 2011).  Secchi observations at each station were used to evaluate changes in light requirements of seagrass at approximate biennial intervals from 1988 to 2014. Stations are labelled by their designation and were chosen based on continuity of data for the period of interest.  HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:tb_ts_locs}
\end{figure}

% estimated light requirements for Choctawhatchee Bay, z_cmax
<<light_choc_zcmax, echo = F, eval = T, cache = T, include = FALSE, results = 'hide'>>=

library(grid)

# reset digits to default
options(digits = 7)

data(choc_light_zcmax)
data(choc_seg)

# centroids for labels
labs <- data.frame(rgeos::gCentroid(choc_seg, byid = T))
labs$seg <- choc_seg$seg

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(choc_light_zcmax)
dat$seg <- factor(dat$seg, levels = c('WCB', 'CCB', 'ECB'))
dat <- dat[dat$light < 80, ]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8, size = 3) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max']) ~ (m)), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) +
  scalebar(location = 'bottomleft', y.min = 30.375, y.max = 30.44, x.min = -86.64, x.max = -86.5, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none', 
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmax
# reorder seg labels
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") + 
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.x = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  )

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8, size = 3) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(
  legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('Light requirements (% SI)') +
  theme_classic() +
  theme(axis.title.x = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  )

# for filler
blankPanel <- grid.rect(gp=gpar(col="white"))

# align
# Get the widths
pA <- ggplot_gtable(ggplot_build(p1))
pB <- ggplot_gtable(ggplot_build(p2))
pC <- ggplot_gtable(ggplot_build(p3))
pD <- ggplot_gtable(ggplot_build(p4))
maxWidth = grid::unit.pmax(pA$widths[2:3], pB$widths[2:3], pD$widths[2:3], pD$widths[2:3])

# Set the widths
pA$widths[2:3] <- maxWidth
pB$widths[2:3] <- maxWidth
pC$widths[2:3] <- maxWidth
pD$widths[2:3] <- maxWidth

pdf('figs/FigS3.pdf', height = 8, width = 8, family = 'serif')
grid.arrange(pA, p1leg, pB, blankPanel, pC, p3leg, pD, blankPanel, 
  ncol = 2, nrow = 4, 
  widths = c(1, 0.2), heights = c(1, 0.7, 1, 0.7))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/FigS3.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Choctawhatchee Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.04 decimal degrees.  Estimates are also summarized by bay segment as boxplots where the dimensions are the 25\textsuperscript{th} percentile, median, and 75\textsuperscript{th} percentile.  Whiskers extend to the 5\textsuperscript{th} and 95\textsuperscript{th} percentiles with outliers beyond. CCB: Central Choctawhatchee Bay, ECB: East Choctawhatchee Bay, WCB: West Choctawhatchee Bay.}
\label{fig:light_choc_zcmax}
\end{figure}

% estimated light requirements for Tampa Bay, z_cmax
<<light_tb_zcmax, echo = F, eval = T, cache = T, results = 'hide'>>=
# reset digits to default
options(digits = 7)

data(tb_light_zcmax)
data(tb_seg)

# centroids for labels
labs <- data.frame(rgeos::gCentroid(tb_seg, byid = T))
labs$seg <- c('HB', 'LTB', 'MTB', 'OTB')

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(tb_light_zcmax)
# outs <- quantile(dat$light, c(0.05, 0.95))
# dat <- dat[dat$light > outs[1] & dat$light < outs[2],]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max']) ~ (m)), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) + 
  scalebar(location = 'bottomright', y.min = 27.53, y.max = 27.63, x.min = -82.58, x.max = -82.41, 
    dist = 5, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmax
# reorder seg labels
segs <- c('LTB', 'MTB', 'HB', 'OTB')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) +
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
  ) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) +
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

pdf('figs/FigS4.pdf', height = 7.5, width = 7, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/FigS4.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Tampa Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.1 decimal degrees.  Estimates are also summarized by bay segment as boxplots as in \cref{fig:light_choc}. HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:light_tb_zcmax}
\end{figure}

% estimated light requirements for Indian River Lagoon, z_cmax
<<light_irl_zcmax, echo = F, eval = T, cache = T, results = 'hide'>>=

# reset digits to default
options(digits = 7)

data(irl_light_zcmax)

data(irl_seg)

# centroids for labels, offset
labs <- data.frame(rgeos::gCentroid(irl_seg, byid = T, id = irl_seg$seg))
labs$x <- labs$x - 0.3
labs$seg <- rownames(labs)
labs <- labs[!labs$seg %in% c('LSL', 'LHR'), ]

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(irl_light_zcmax)

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$z_c_all, to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max']) ~ (m)), range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max']) ~ (m)), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend()) + 
  scalebar(location = 'bottomleft', y.min = 27.16, y.max = 27.5, x.min = -81.2, x.max = -80, 
    dist = 30, dd2km= TRUE, model='WGS84', st.dist=.1, st.size = 2, height = 0.07)

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots by seg, z_cmax
# reorder seg labels
segs <- c('LSL', 'LIRL', 'LCIRL', 'UCIRL', 'BR', 'UIRL', 'LML', 'UML')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat$light, to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = group)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% SI', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none',
  axis.line.x = element_line(), 
  axis.line.y = element_line()
  )

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  stat_summary(fun.data = f, geom = "boxplot", fill = fill_col) + 
  stat_summary(fun.y = o, geom = "point") +
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank(),
    axis.line.x = element_line(), 
    axis.line.y = element_line()
    ) + 
  coord_flip()

pdf('figs/FigS5.pdf', height = 8.5, width = 6.5, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()

options(digits = 1)
@
\begin{figure}
\centering
\includegraphics[width = 0.8\textwidth]{figs/FigS5.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Indian River Lagoon, Florida.  Map locations are georeferenced observations of water clarity in the Florida \acl{IWR} database, update 40.  Estimates are also summarized by bay segment as boxplots as in \cref{fig:light_choc}. Light requirements are based on averaged secchi values within ten years of the seagrass coverage data and estimated maximum depth of colonization using a radius of 0.15 decimal degrees for each secchi location to sample seagrass depth points. BR: Banana R., LCIRL: Lower Central Indian R. Lagoon, LIRL: Lower Indian R. Lagoon, LML: Lower Mosquito Lagoon, LSL: Lower St. Lucie, UCIRL: Upper Central Indian R. Lagoon, UIRL: Upper Indian R. Lagoon, UML: Upper Mosquito Lagoon.}
\label{fig:light_irl_zcmax}
\end{figure}

\end{document}