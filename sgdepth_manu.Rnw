\documentclass[letterpaper,12pt,oneside]{article}
\usepackage[paperwidth=8.5in,paperheight=11in,top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{setspace}
\usepackage[colorlinks=true,allcolors=Blue]{hyperref}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{rotating}
\usepackage{tabularx}
\usepackage{outlines}
\usepackage{lineno}
\usepackage{array}
\usepackage{times}
\usepackage{cleveref}
\usepackage{acronym}
\usepackage[position=t]{subfig}
\usepackage{paralist}
\usepackage[noae]{Sweave}
\usepackage{natbib}
\usepackage{array}
\usepackage{pdflscape}
\usepackage{bm}
\usepackage{showlabels}
\bibpunct{(}{)}{,}{a}{}{,}

% page margins and section title formatting
\linespread{1.5}
\setlength{\footskip}{0.5in}
\titleformat*{\section}{\Large\bf\em}
\titleformat*{\subsection}{\singlespace\large\bf}
\titleformat*{\subsubsection}{\singlespace\normalsize\bf\em}
\titlespacing{\section}{0in}{0in}{0in}
\titlespacing{\subsection}{0in}{0in}{0in}
\titlespacing{\subsubsection}{0in}{0in}{0in}

% cleveref options
\crefname{table}{Table}{Tables}
\crefname{figure}{Fig.}{Figs.}
\renewcommand{\figurename}{Fig.}

% aliased citations
\defcitealias{HagyIR}{Hagy, In review}
\defcitealias{USEPA06}{USEPA, 2006}
\defcitealias{USEPA98}{USEPA, 1998}

%acronyms
\acrodef{DEM}{Digital Elevation Model}
\acrodef{EPA}{Environmental Protection Agency}
\acrodef{doc}[$Z_c$]{depth of colonization}
\acrodef{GIS}{Geographic Information System}
\acrodef{IWR}{Impaired Waters Rule}
\acrodef{MSL}{mean sea level}
\acrodef{NAVD88}{North American Vertical Datum of 1988}
\acrodef{NOAA}{National Oceanic and Atmospheric Administration}

%knitr options
<<setup,include=F,cache=F>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path = 'figs/', fig.align='center', fig.show='hold',message=F,echo=F,results='asis',dev='pdf',dev.args=list(family='serif'),fig.pos='!ht',warning=F)
options(replace.assign=TRUE,width=90,digits=1)
source('R/funcs.r')
@

\begin{document}

\raggedbottom
\linenumbers
\raggedright
\urlstyle{same}
\setlength{\parindent}{0.5in}
\renewcommand\refname{References \vspace{12pt}}

\begin{singlespace}
\title{{\bf {\Large Quantifying seagrass light requirements using an algorithm to spatially resolve depth of colonization}}}
\author{
  {\bf {\normalsize Marcus W. Beck$^1$, James D. Hagy III$^2$}}
  \\\\{\textit {\normalsize $^1$ORISE Research Participation Program}}
  \\{\textit {\normalsize USEPA National Health and Environmental Effects Research Laboratory}}
  \\{\textit {\normalsize Gulf Ecology Division, 1 Sabine Island Drive, Gulf Breeze, FL 32561}}
	\\{\textit {\normalsize Phone: 850-934-2480, Fax: 850-934-2401, Email: \href{mailto:beck.marcus@epa.gov}{beck.marcus@epa.gov}}}
  \\\\{\textit {\normalsize $^2$USEPA National Health and Environmental Effects Research Laboratory}}
	\\{\textit {\normalsize Gulf Ecology Division, 1 Sabine Island Drive, Gulf Breeze, FL 32561}}
	\\{\textit {\normalsize Phone: 850-934-2455, Fax: 850-934-2401, Email: \href{mailto:hagy.jim@epa.gov}{hagy.jim@epa.gov}}}
	}
\date{}
\maketitle
\end{singlespace}
\clearpage

\section{Introduction}

Seagrasses are ecologically valuable components of aquatic systems that serve a structural and functional role in shaping aquatic habitat.  These `ecosystem engineers' often govern multiple characteristics of aquatic systems through direct and indirect interactions with additional components \citep{Jones94,Koch01}.  For example, seagrass beds create desirable habitat for juvenile fish and invertebrates by reducing wave action and stabilizing sediment \citep{williams01,Hughes09}.  Seagrasses also respond to changes in water clarity through direct physiological linkages with light availability.  Seagrass communities in highly productive aquatic systems may be light-limited as increased nutrient loading may contribute to reductions in water clarity through increased algal concentration \citep{Duarte95}.  Empirical relationships between nutrient loading, water clarity, light requirements, and the maximum depth of seagrass colonization have been identified \citep{Duarte91,Kenworthy96,Choice14} and are often used to characterize light regimes sufficient to maintain habitat through increased seagrass coverage \citep{Steward05}.  Seagrass depth limits have also been used to establish quantititative criteria for nutrient load targets for the maintenance of water quality \citep{Janicki96}.  Seagrasses are integrative of system-wide conditions over time in relation to changes in nutrient regimes \citep{Duarte95} and are often preferred biological endpoints to describe ecosytem response to perturbations relative to more variable taxa (e.g., phytoplankton).  Quantifying the relationship of seagrasses with water clarity is a viable means of understanding ecological characteristics of aquatic systems with potential insights into resilience and stability of system response to disturbance \citep{Greve05}.    

A variety of techniques have been developed for estimating seagrass depth limits as a basis for understanding water quality dynamics and developing a more robust description of aquatic habitat.  Such efforts have been useful for site-specific approaches where the analysis needs are driven by a particular management or research question \citep[e.g.,][]{Iverson86,Hale04}. However, a lack of standardization among methods has prevented broad-scale comparisons between regions and has even contributed to discrepancies between measures of depth limits based on the chosen technique.  For example, seagrass depth limits based on in situ techniques can vary with the sampling device \citep{Spears09}.  Seagrass depth limits can also be estimated from geospatial data that describe aerial coverage and bathymetric depth distribution.  Despite the availability of such data, flexible techniques for estimating seagrass depth of colonization have not been extensively developed nor have standardized techniques been implemented across broad areas.  Site-specific approaches typically involve the quantification of depth limits within a predefined management unit as a relevant spatial context. For example, \cite{Steward05} describe use of a segmentation scheme for the Indian River Lagoon on the Atlantic coast of Florida to assign seagrass depth limits to 19 distinct geospatial units.  Although useful within a limited scope, substantial variation in growth patterns and water quality characteristics at different spatial scales may prevent more detailed analyses, thus leading to limited descriptions of aquatic habitat.  Methods for estimating seagrass depth limits should be reproducible for broad-scale comparisons, while also maintaining flexibility of  estimates depending on research or managment objectives. Such techniques have the potential to facilitate comparisons between regions given the spatial coverage and annual availability of many geospatial data sources.  

A useful application comparing depth limit measures and water clarity is the estimation of light requirements to evaluate ecologically relevant characterisics of seagrass communities.  Although growth of submersed aquatic plants is generally most limited by light availability \citep{Barko82,Hall90,Dennison93}, substantial variation for a given level of light may be observed in the maximum depth of growth based on differences in light requirements \citep{Dennison93,Choice14}.  In general, seagrasses with low light requirements are expected to grow deeper than seagrasses with high requirements as related to species or regional differences in community attributes.  Significant variation in light requirements in seagrasses along the Gulf Coast of peninsular Florida were attributed to morphological and physiological differences between species and adaptations to regional light regimes \citep{Choice14}.  Minimum light requirements for seagrasses are on average 11\% of surface irradiance \citep{Duarte91}, although values may range from less than 5\% to greater than 30\% at depth \citep{Dennison93}. High light requirements estimated from maximum depth of colonization and water clarity may suggest seagrass growth is limited by additional factors, such as high biomass of epiphytic algal growth that reduces light availability on the leaf surface \citep{Kemp04}. Spatial heterogeneity in light requirements is, therefore, a useful diagnostic tool for evaluating potential factors that limit seagrass growth. 

A potentially limiting factor for estimating seagrass light requirements is the availability of water clarity data that are evenly distributed through space in time, in addition to accurate measures of depth of colonization.  Secchi observations are routine measurements that can provide consistent measures of water clarity \citepalias{USEPA06}, although the distribution of available data may limit the the certainty within which light requirements can be estimated.  Secchi data can be biased by location such that monitoring programs may have unbalanced coverage towards aquatic resources with greater perceived importance relative to those that may have more ecological significance \citep{Wagner08,Lottig14}.  Morever, infrequent field measurements that are limited to discrete time periods are often more descriptive of short-term variability rather than long-term trends in water clarity \citep{Elsdon09}.  Seagrasses growth patterns are integrative of seasonal and inter-annual patterns in water clarity, among other factors, such that estimates of light requirements may be limited if water clarity measurements inadequately describe temporal variation.  Remote sensing products can provide a reasonable estimate of water clarity and could be used to develop a more spatially and temporally coherent description of relevant ecosystem characteristics.  Although algorithms have been developed for coastal waters that relate surface reflectance to \textit{in situ} data \citep{Woodruff99,Chen07}, this information has rarely been used to develop a description of seagrass light requirements at a spatial resolution consistent with most remote sensing products.    

Quantitative and flexible methods for estimating seagrass depth limits and light requirements have the potential to greatly improve descriptions of aquatic habitat, thus enabling potentially novel insights into ecological characteristics that limit aquatic systems.  This article describes a method for estimating seagrass depth of colonization using geospatial datasets to create a spatially-resolved and flexible measure.  In particular, an empirical algorthm is described that estimates seagrass depth limits from aerial coverage maps and bathymetric data using an \textit{a priori} defined area of influence. These estimates are combined with measures of water clarity to provide a spatial characterization of light requirements to better understand factors that limit seagrass growth.  The specific objectives are to\begin{inparaenum}[1\upshape)]
\item describe the method for estimating seagrass depth limits within a relevant spatial context, 
\item apply the technique to four distinct regions of Florida to illustrate improved clarity of description for seagrass growth patterns, and
\item develop a spatial description of depth limits, water clarity, and light requirements for the case studies.  
\end{inparaenum}
Overall, these methods are expected to inform the description of seagrass growth patterns to develop a more ecologically relevant characterization of aquatic habitat.  The method is applied to data from Florida although the technique is easily transferable to other regions with comparable data. 

\section{Methods}

Estimates of seagrass \ac{doc} that are derived from relatively broad spatial aggregations, such as predefined management areas, may not fully describe relevant variation depending on the question of interest. \Cref{fig:buff_ex1} shows variation in seagrass distribution for a management segment (thick polygon) in the Big Bend region of Florida.  The maximum depth colonization, shown as a red countour line, is based on a segment-wide average of all seagrasses within the polygon.  Although such an estimate is not necessarily inaccurate, substantial variation in seagrass growth patterns at smaller spatial scales is not adequately described. In particular, \ac{doc} is greatly over-estimated at the outflow of the Steinhatchee River (northeast portion of the segment) where high concentrations of dissolved organic matter reduce water clarity and naturally limit seagrass growth (personal communication, Nijole Wellendorf, Florida Department of Environmental Protection).  This example suggests that it may be useful to have improved spatial resolution in estimates of \ac{doc}, particularly when site-specific characteristics may require a more detailed description of seagrass growth patterns.  The following is a summary of data sources, methods and rationale for developing a flexible algorithm that improves spatial resolution in seagrass \ac{doc} estimates.  Data and methods described in \citetalias{HagyIR} are used as a foundation for developing the approach.

\subsection{Data sources}

\subsubsection{Study sites}

Three locations in Florida were chosen for the analysis: the Big Bend region (northeast Gulf of Mexico), Tampa Bay (central Gulf Coast), and Indian River Lagoon (east coast) (\cref{tab:seg_summ,fig:seg_all}).  These locations represent different geographic regions in the state, in addition to having available data and observed gradients in water clarity that contribute to heterogeneity in seagrass growth patterns. Coastal regions and estuaries in Florida are partitioned as distinct spatial units based on a segmentation scheme developed by US \ac{EPA} for the development of numeric nutrient criteria.  Site-specific estimates of seagrass depth colonization and light requirements are the primary focus of the analysis, with emphasis on improved clarity of description with changes in spatial context.  As such, estimates that use management segments as relevant spatial units are used as a basis of comparison to evaluate variation in growth patterns at difference scales.  The segments included the big bend region (820), Old Tampa Bay (902), and Indian River Lagoon (1502) (\cref{fig:seg_all}).   

\subsubsection{Seagrass coverage and bathymetry} \label{sec:data_srcs}

Spatial data describing seagrass aerial coverage combined with co-located bathymetric depth information were used to estimate \ac{doc}.  These geospatial data products are pubically available in coastal regions of Florida through the US Geological Survey, Florida Department of Environmental Protection, Florida Fish and Wildlife Conservation Commission, and watershed management districts.  Seagrass coverage maps were obtained for recent years in each of the study sites described above (\cref{tab:seg_summ}).  Coverage maps were produced using photo-interpretations of aerial images to categorize seagrass as absent, discontinuous (patchy), or continuous.  For this analysis, we considered seagrass as only present (continuous and patchy) or absent since differences between continuous and patchy coverage were often inconsistent between data sources. 

Bathymetric depth layers for each location were obtained from the National Oceanic and Atmospheric Administration's (\acsu{NOAA}) National Geophysical Data Center (\url{http://www.ngdc.noaa.gov/}) as either \acp{DEM} or raw sounding data from hydroacoustic surveys.  Tampa Bay data provided by the Tampa Bay National Estuary Program are described in \citet{Tyler07}. Bathymetric data for the Indian River Lagoon were obtained from the St. John's Water Management District \citep{CPE97}.  \ac{NOAA} products were referenced to mean lower low water, whereas Tampa Bay data were referenced to the \ac{NAVD88} and the Indian River Lagoon data were referenced to mean sea level.  Depth layers were combined with seagrass coverage layers using standard union techniques for raster and vector layers in ArcMap 10.1 \citep{ESRI12}.  To reduce computation time, depth layers were first masked using a 1 km buffer of the seagrass coverage layer.  Raster bathymetric layers were converted to vector point layers to combine with seagrass coverage maps, described below.  All spatial data were referenced to the North American Datum of 1983 as geographic coordinates.  Depth values in each seagrass layer were further adjusted from the relevant vertical reference datum to local \ac{MSL} using the \ac{NOAA} VDatum tool (\url{http://vdatum.noaa.gov/}).

\subsubsection{Water clarity and light attenuation}

Seagrass light requirements can be estimated by evaluating spatial relationships between depth of colonization and water clarity.  These relationships were explored using \ac{doc} estimates for the whole of Tampa Bay and the Indian River Lagoon based on large gradients in water clarity along longitudinal axes in each bay (cites). Satellite images were used to create a gridded map of water clarity based on a previously-developed algorithm to derive light attenuation (or light extinction coefficient $K_Z$) from surface reflectance \citep{Chen07}.  This approach was preferred for Tampa Bay given the annual availability and the extent of coverage of remote sensing data.  Daily MODIS (Aqua level-2) data from January 2003 to December 2010 that covered the spatial extent of Tampa Bay were downloaded from the NASA website (\url{http://oceancolor.gsfc.nasa.gov/}). These images were reprocessed using the SeaWiFS Data Analysis System software (SeaDAS, Version 7.0). We used the clarity algorithm proposed by \citet{Chen07} to derive monthly mean and annual mean light attenuation coefficients for Tampa Bay. Secchi data (meters, $Z_{secchi}$) were also obtained from update 40 of the \ac{IWR} database for all of the Indian River Lagoon (2009 coverage). Satellite estimates of water clarity were unobtainable in the Indian River Lagoon because of significant light scattering from bottom reflectance and limited resolution for extended narrow segments along the north-south axis.  Secchi data within the previous ten years of the seagrass coverage data were evaluated to capture water quality trends from the most recent decade (i.e., 1999--2009 for the Indian River Lagoon).  Stations with less than five observations and observations that were flagged indicating that the value was lower than the maximum depth of the observation point were removed.  Secchi data were also compared with bathymetric data to verify unflagged values were not missed by initial screening. 

\subsection{Flexible estimation of seagrass depth of colonization for finite areas}

The general approach to estimating seagrass \acl{doc} uses combined seagrass coverage maps and bathymetric depth data described above.  The combined layer used for analysis was a point shapefile with attributes describing location (latitude, longitude, segment), depth (m), and seagrass (present, absent).  Seagrass \ac{doc} values are estimated from these data by quantifying the proportion of points with seagrass at each observed depth.  Three unique measures describing seagrass depth limits obtained from these data are minimum ($Z_{c,\,min}$), median ($Z_{c,\,med}$), and maximum ($Z_{c,\,max}$) \acl{doc}.  Operationally, these terms describe characteristics of the seagrass coverage map with quantifiable significance. $Z_{c,\,max}$ is defined as the deepest depth at which a significant coverage of mappable seagrasses occured independent of outliers, whereas  $Z_{c,\,med}$ is the median depth occurring at the deep water edge. $Z_{c,\,min}$ is the depth at which seagrass coverage begins to decline with increasing depth and may not be statistically distinguishable from zero depth, particularly in turbid waters. Specific methods for estimating each \ac{doc} value using spatially-resolved information are described below. 

The spatially-resolved approach for estimating \ac{doc} begins by choosing an explicit location in cartesian coordinates within the general boundaries of the available data.  Seagrass depth data (i.e., merged bathymetric and seagrass coverage data) that are located within a set radius from the chosen location are selected for estimating seagrass \ac{doc} values (\cref{fig:buff_ex}). The estimate for each location is quantified from a plot of the proportion of sampled points that contain seagrass at decreasing 0.1 meter depth bins from the surface to the maximum observed depth in the sample (\cref{fig:est_ex1}).  Although the chosen radius for selecting depth points is problem-specific, the minimum radius should be chosen to sample a sufficient number of points for estimating \ac{doc}.  In general, an appropriate radius will produce a plot that indicates a decrease in the proportion of points that are occupied by seagrass with increasing depth. If more than one location is used to estimate \ac{doc}, appropriate radii for each point would have minimal overlap with the seagrass depth data sampled by neighboring points.     

A curve is fit to the sampled depth points using non-linear regression to characterize the reduction in seagrass as a function of depth (\cref{fig:est_ex2}).  Specifically, a decreasing logistic growth curve is used with the assumption that seagrass decline with increasing depth is monotonic and asymptotic at the minimum and maximum depths of colonization. The curve is fit by minimizing the residual sums-of-squares with the Gauss-Newton algorithm \citep{Bates92} with starting parameters estimated from the observed data that are initial approximations of the curve characteristics.  The model has the following form:
\begin{equation} \label{eqn:prop}
 Proportion = \frac{\alpha}{1 + \mathrm{e}^{{\left(\beta - Z\right)/\gamma}}}
\end{equation}
where the proportion of points occupied by seagrass at each depth, $Z$, is defined by a logistic curve with an asymptote $\alpha$, a midpoint inflection $\beta$, and a scale parameter $\gamma$.  Finally, a simple linear curve is fit through the inflection point ($\beta$) of the logistic curve to estimate the three measures of depth of colonization (\cref{fig:est_ex3}).  The inflection point is considered the depth at which seagrass are decreasing at a maximum rate and is used as the slope of the linear curve.  The maximum depth of seagrass colonization, $Z_{c,\,max}$, is the x-axis intercept of the linear curve.  The minimum depth of seagrass growth, $Z_{c,\,min}$, is the location where the linear curve intercepts the upper asymptote of the logistic growth curve.  The median depth of seagrass colonization, $Z_{c,\,med}$, is the depth halfway between $Z_{c,\,min}$ and $Z_{c,\,max}$.  $Z_{c,\,med}$ is typically the inflection point of the logistic growth curve.

Estimates for each of the three \ac{doc} measures are obtained only if specific criteria are met.  These criteria were implemented as a safety measure that ensures a sufficient amount and appropriate quality of data were sampled within the chosen radius.  First, estimates were provided only if a sufficient number of seagrass depth points were present in the sampled data to estimate a logistic growth curve.  This criteria applies to the sample size as well as the number of points with seagrass in the sample.  Second, estimates were provided only if an inflection point was present on the logistic curve within the range of the sampled depth data.  This criteria applied under two scenarios where the curve was estimated but a trend was not adequately described by the sampled data.  That is, estimates were unavailabled if hte logistic curve described only the initial decrease in points occupied as a function of depth but the observed points do not occur at depths deeper than the predicted inflection point.  The opposite scenario occurred when a curve was estimated but only the deeper locations beyond the inflection point were present in the sample.  Third, the estimate for $Z_{c,\,min}$ was set to zero depth if the linear curve through the inflection point intercepted the asymptote at x-axis values less than zero.  The estimate for $Z_{c,\,med}$ was also shifted to the depth value halfway between $Z_{c,\,min}$ and $Z_{c,\,max}$ if $Z_{c,\,min}$ was fixed at zero.  Finally, estimates were considered invalid if the 95\% confidence interval for $Z_{c,\,max}$ included zero.  Methods used to  determine confidence bounds on \ac{doc} estimates are described below.  

\subsection{Estimating uncertainty in \acl{doc} estimates}

Confidence intervals for the \ac{doc} values were estimated using a Monte Carlo simulation approach that considered the variance and covariance between the model parameters \citep{Hilborn97}.  For simplicity, we assume that the variability associated with parameter estimates is the dominant source of uncertainty.  A 95\% confidence interval for each \ac{doc} estimate was constructed by repeated sampling of a multivariate normal distribution followed by prediction of the proportion of points occupied by seagrass as in \cref{eqn:prop}.  The sampling distribution assumes:
\begin{equation}
x \sim N(\mu, \Sigma)
\end{equation}
\noindent where $x$ is a predictor variable used in \cref{eqn:prop} (depth) that follows a multivariate normal distribution with mean $\mu$, and variance-covariance matrix $\Sigma$.  The mean values are set at the depth value corresponding to the inflection point on the logistic curve and the predicted model parameters (i.e., $\alpha$, $\beta$, and $\gamma$), whereas $\Sigma$ is the variance-covariance matrix of the model parameters.  A large number of samples ($n = 10000$) were drawn from the distribution to characterize the uncertainty of the depth value at the inflection point.  The 2.5\textsuperscript{th} and 97.5\textsuperscript{th} quantile values of the sample were considered bounds on the 95\% confidence interval.

The uncertainty associated with the \ac{doc} estimates was based on the upper and lower limits of the estimated inflection point on the logistic growth curve.  This approach was used because uncertainty in the inflection point is directly related to uncertainty in each of the \ac{doc} estimates that are based on the linear curve fit through the inflection point.   Specifically, linear curves were fit through the upper and lower estimates of the depth value at the inflection point to identify upper and lower limits for the estimates of $Z_{c,\,min}$, $Z_{c,\,med}$, and $Z_{c,\,max}$.  These values were compared with the initial estimates from the linear curve that was fit through the inflection point on the predicted logistic curve (i.e., \cref{fig:est_ex3}).  This approach provided an indication of uncertainty for individual estimates for the chosen radius.  Uncertainty estimates were obtained for each \ac{doc} estimate for the grids in each segment.

The algorithm for estimating \ac{doc} was implemented custom-made and pre-existing functions in program R.  Nonlinear least squares models were based on the \texttt{nls} and \texttt{SSlogis} functions that used a self-starting logistic growth model \citep{Bates92,RDCT14}.  Multivariate normal distributions used to evaluate uncertainty were simulated using functions in the MASS package \citep{Venables02}.  Geospatial data were imported and processed using functions in the rgeos and sp packages \citep{Bivand08,Bivand14}.  

\subsection{Evaluation of spatial heterogeneity of seagrass depth limits}

Spatially-resolved estimates for seagrass \ac{doc} were obtained for each of the four coastal segments described above.  Segment-wide estimates obtained using all data were used as a basis of comparison such that departures from these values at smaller scales were evidence of spatial heterogeneity in seagrass growth patterns and improved clarity of description in depth estimates.  A sampling grid of locations for estimating each of the three depth values in \cref{fig:est_ex} was created for each segment.  The grid was masked by the segment boundaries, whereas seagrass depth points used to estimate \ac{doc} extended beyond the segment boundaries to allow sampling by grid points that occurred near the edge of the segment.  Initial spacing between sample points was chosen arbitrarily as 0.01 decimal degrees, which is approximately 1 km at 30 degrees N latitude.  The sampling radius around each sampling location in the grid was also chosen as 0.02 decimal degrees to allow for complete coverage of seagrass within the segment while also minimizing redundancy of information described by each location.  In other words, radii were chosen such that the seagrass depth points sampled by each grid location were only partially overlapped by those sampled by neighboring points, while also ensuring an adequate number of locations were sampled that included seagrass.

\subsection{Developing a spatially coherent relationship of water clarity with depth of colonization}

The relationship between the quantified seagrass depth limits and secchi measurements were explored by estimating light requirements from standard attenuation equations.  The traditional Lambert-Beer equation describes the exponential decrease of light availability with depth:
\begin{equation} \label{eqn:lambeer}
I_{z} = I_{O} \cdot \exp\left(-K_{Z} \cdot Z\right)
\end{equation}
\noindent such that the irradiance of incident light at depth $Z$ ($I_{Z}$) can be estimated from the irradiance at the surface ($I_{O}$) and a light extinction coefficient ($K_{Z}$). Light requirements of seagrass at a specific location can be estimated by rearranging \cref{eqn:lambeer}:
\begin{equation} \label{eqn:perclight}
\% \ light = \exp\left(-K_{Z} \cdot Z_{c,\,max}\right)
\end{equation}
\noindent where the percent light requirements of seagrass at $Z_{c,\,max}$ are empirically related to light extinction. A conversion factor is often used to estimate the light extinction coefficient from secchi depth $Z_{secchi}$, such that such that $c = K_{Z} \cdot Z_{secchi}$, where $c$ has been estimated as 1.7 \citep{Poole29,Idso74}.  Thus, $K_{Z}$ can be replaced with the conversion factor and $Z_{secchi}$:
\begin{equation} \label{eqn:cperclight}
\% \ light = \exp\left(-\left(\frac{1.7}{Z_{secchi}}\right)\cdot Z_{c,\,max}\right)
\end{equation}
\noindent Variation in seagrass light requirements by location can be considered biologically meaningful. 

An evenly-spaced grid of sampling points was created for the spatial extent of Tampa Bay to estimate light requirements for seagrasses. Grid spacing was set at 0.01 decimal degrees as before. These points were used to sample the raster grid of satellite-derived water clarity and the seagrass depth points to  estimate $Z_{c,\,max}$.  Similarly, the geographic coordinates for each available secchi measurement in the Indian River Lagoon were used as locations for estimating $Z_{c,\,max}$.  These estimates were compared with the averaged water clarity or secchi data for all preceding years to identify seagrass light requirements at each location (i.e., 2003--2010 for Tampa Bay and 1999--2009 for Indian River Lagoon).  However, the relationship may vary depending on the specific radius around each sample point for estimating $Z_{c,\,max}$.  A sufficiently large radius was chosen that was an order of magnitude larger than that used for the individual segments given that $Z_{c,\,max}$ estimates were to be compared for whole bays rather than within segments.  The estimated maximum depth values and light requirements of each point were plotted by location to evaluate spatial variation in seagrass growth as a function of light-limitation.

\section{Results}

\subsection{Segment characteristics and seagrass depth estimates}

% data for inline expressions
<<echo = F>>=
data(seg_summ)

# surface areas
areas <- seg_summ[row.names(seg_summ) %in% 'Surface area',]
areas <- as.numeric(areas)
names(areas) <- names(seg_summ)

# seagrass percent coverage
sgperc <- seg_summ[row.names(seg_summ) %in% 'Seagrass area',]
sgperc <- 100 * as.numeric(sgperc) / areas
names(sgperc) <- names(seg_summ)

# mean depth
depths <- seg_summ[row.names(seg_summ) %in% 'Depth (mean)',]
depths <- as.numeric(depths)
names(depths) <- names(seg_summ)

#max depths
mdepths <- seg_summ[row.names(seg_summ) %in% 'Depth (max)',]
mdepths <- as.numeric(mdepths)
names(mdepths) <- names(seg_summ)

# secchi depths
secchis <- seg_summ[row.names(seg_summ) %in% 'Secchi (mean)',]
secchis <- as.numeric(secchis)
names(secchis) <- names(seg_summ)
@

Each of the four segments varied by several key characteristics that potentially explain within-segment variation of seagrass growth patterns (\cref{tab:seg_summ}).  Mean surface area was \Sexpr{mean(areas)} square kilometers, with area decreasing for the Big Bend (\Sexpr{areas['Big Bend']} km), Indian River Lagooon (\Sexpr{areas['Indian River Lagoon']} km), Old Tampa Bay (\Sexpr{areas['Old Tampa Bay']} km), and Choctawhatchee Bay (\Sexpr{areas['Choctawhatchee Bay']} km) segments.  Seagrass coverage as a percentage of total surface area varied considerably by segment.  Seagrasses covered a majority of the surface area for the Big Bend segment (\Sexpr{sgperc['Big Bend']} \%), whereas coverage was much less for Indian River Lagoon (\Sexpr{sgperc['Indian River Lagoon']} \%), Old Tampa Bay (\Sexpr{sgperc['Old Tampa Bay']} \%), and Choctawhatchee Bay (\Sexpr{sgperc['Choctawhatchee Bay']} \%).  Visual examination of the seagrass coverage maps for the respective year of each segment suggested that seagrasses were not uniformly distributed (\cref{fig:seg_all}).  Seagrasses in the Choctawhatchee Bay segments were generally sparse with the exception of a large patch located to the west of the inlet connection with the Gulf of Mexico.  Seagrasses in the Big Bend segment were located throughout the segment with noticeable declines near the outflow of the Steinhatchee River, whereas seagrasses in Old Tampa Bay and the Indian River Lagoon segment were generally confined to shallow areas near the shore. Seagrass coverage showed a partial decline toward the northern ends of both Old Tampa Bay and the Indian River Lagoon segments.  Mean depth was less than 5 meters for each segment, excluding Choctawhatchee Bay which was slightly deeper than the other segments on average (\Sexpr{depths['Choctawhatchee Bay']} m).  Maximum depths were considerably deeper for Choctawhatchee Bay (\Sexpr{mdepths['Choctawhatchee Bay']} m) and Old Tampa Bay (\Sexpr{mdepths['Old Tampa Bay']} m), as compared to the Big Bend (\Sexpr{mdepths['Big Bend']} m) and Indian River Lagoon (\Sexpr{depths['Indian River Lagoon']} m) segments.  Water clarity as indicated by average secchi depths was similar between the segments (\Sexpr{mean(secchis)} m), although Choctawhatchee Bay had a slightly higher average (\Sexpr{secchis['Choctawhatchee Bay']} m).     

% seagrass estimates from table
<<echo = F>>=
data(ests_seg)
data(ests_out)

# big bend doc max diff
bb_ests <- mean(ests_out[ests_out$seg == '820', 'z_cmax'])

# irl estimates
irl_maxdocmin <- max(ests_out[ests_out$seg == '1502', c('z_cmin')])
irl_meandocmax <- mean(ests_out[ests_out$seg == '1502', c('z_cmax')])
irl_maxdocmax <- max(ests_out[ests_out$seg == '1502', c('z_cmax')])
@

Estimates of seagrass \ac{doc} using a segment-wide approach that did not consider spatially explicit locations indicated that seagrasses generally did not grow deeper than three meters in any of the segments (\cref{tab:est_summ}).  Maximum and median depth of colonization were deepest for the Big Bend segment (\Sexpr{ests_seg[ests_seg$seg == '820', 'z_cmax']} and \Sexpr{ests_seg[ests_seg$seg == '820', 'z_cmed']} m, respectively) and shallowest for Old Tampa Bay (\Sexpr{ests_seg[ests_seg$seg == '902', 'z_cmax']} and \Sexpr{ests_seg[ests_seg$seg == '902', 'z_cmed']} m), whereas the minimum depth of colonization was deepest for Choctawhatchee Bay (\Sexpr{ests_seg[ests_seg$seg == '303', 'z_cmin']} m) and shallowest for Old Tampa Bay (\Sexpr{ests_seg[ests_seg$seg == '902', 'z_cmin']} m).  Averages of all grid-based estimates for each segment were different than the segment wide estimates, which suggests potential bias associated with using a whole segment as a relevant spatial unit for estimating depth of colonization.  In most cases, the averages of all grid-based estimates were less than the whole segment estimates, suggesting the latter provided an over-estimate of seagrass growth limits.  For example, the average of all grid estimates for $Z_{c,\,max}$ in the Big Bend region suggested seagrasses grew to approximately \Sexpr{bb_ests} m, which was \Sexpr{ests_seg[ests_seg$seg == '820', 'z_cmax'] - bb_ests} m less than the whole segment estimate.  This reduction is likely related to improved resolution of seagrass depth limits near the outflow of the Steinhatchee river.  Although reductions were not as severe for the average grid estimates for the remaining segments, considerable within-segment variation was observed depending on grid location.  For example, the deepest estimate for $Z_{c,\,min}$ (\Sexpr{irl_maxdocmin} m) in the Indian River Lagoon exceeded the average of all grid locations for $Z_{c,\,max}$ (\Sexpr{irl_meandocmax} m).  $Z_{c,\,min}$ also had minimum values of zero meters for the Big Bend and Old Tampa Bay segments, suggesting that seagrasses declined continously from the surface for several locations.   

Visual interpretations of seagrass depth estimates using the grid-based approach provided further information on the distribution of seagrasses in each segment (\cref{fig:all_ests}).  Spatial heterogeneity in depth limits was particularly apparent for the Big Bend and Indian River Lagoon segments.  As expected, depth estimates indicated that seagrasses grew deeper at locations far from the outflow of the Steinhatchee River in the Big Bend segment.  Similarly, seagrasses were limited to shallower depths at the north end of the Indian River Lagoon segment near the Merrit Island National Wildlife Refuge. Seagrases were estimated to grow at maximum depths up to \Sexpr{irl_maxdocmax} m on the eastern portion of the Indian River Lagoon segment.  Spatial heterogeneity was less distinct for the remaining segments.  Seagrasses in Old Tampa Bay grew deeper in the northeast portion of the segment and declined to shallower depths near the inflow at the northern edge.  Spatial variation in the Choctawhatchee Bay segment was not apparent, although the maximum \ac{doc} estimate was observed in the northeast portion of the segment.  \ac{doc} values were not available for all grid locations givne the limitations imposed in the estimation method.  \ac{doc} could not be estimated in locations where seagrasses were sparse or absent, nor where seagrasses were present but the sampled points did not exhibit a sufficient decline with depth.  The latter scenario was most common in Old Tampa Bay and Choctawhatchee Bay where seagrasses were unevenly distributed or confined to shallow areas near the shore.  The former scenario was most common in the Big Bend segment where seagrasses were abundant but locations near the shore were inestimable given that seagrasses did not decline appreciably within the depths that were sampled.   

<<echo = F>>=
data(ests_out)
data(ests_out_nonsigs)

# uncertainty means
means <- dplyr::group_by(ests_out, seg) %>% 
  summarize(means = mean(confint, na.rm = T)) %>% 
  as.data.frame(.)

# uncertainty means
maxs <- dplyr::group_by(ests_out, seg) %>% 
  summarize(maxs = max(confint, na.rm = T)) %>% 
  as.data.frame(.)

# percent non-overlapping
# 'overlapped' indicates percent non-different between depth measures
# interval is non-symmetric but this does not affect overlap
overlap <- dplyr::mutate(ests_out, halved = confint/2) %>% 
  mutate(
    overlapped = (z_cmax - halved) < (z_cmed + halved)
  ) %>% 
  group_by(seg) %>% 
  summarize(
    overlapped = 100 * sum(overlapped)/length(overlapped)
  ) %>% 
  as.data.frame(.)

# of those that were estimable, which had z_cmax sig greater than zero?
nonsigs <- dplyr::mutate(ests_out_nonsigs,
    ltzero = lower_max < 0
  ) %>% 
  group_by(seg) %>% 
  summarize(
    ltzero = 100 * sum(ltzero)/length(ltzero)
  ) %>% 
  as.data.frame(.)

@
Uncertainty for estimates of $Z_{c,\,max}$ indicated that confidence intervals were generally acceptable (i.e., greater than zero), although the ability to discriminate between the three depth estimates varied by segment (\cref{fig:all_sens,tab:sens_summ}).  Mean uncertainty for all estimates in each segment measured as the width of a 95\% confidence interval was \Sexpr{mean(ests_out$confint, na.rm = T)} m.  Greater uncertainty was observed for Choctawhatchee Bay (mean width of all confidence intervals was \Sexpr{means[means$seg == '303', 'means']} m) and Old Tampa Bay (\Sexpr{means[means$seg == '902', 'means']} m), compared to the Big Bend (\Sexpr{means[means$seg == '820', 'means']} m) and Indian River Lagoon (\Sexpr{means[means$seg == '1502', 'means']} m) segments.  The largest confidence interval for each segment was \Sexpr{maxs[maxs$seg == '902', 'maxs']} m for Old Tampa Bay, \Sexpr{maxs[maxs$seg == '303', 'maxs']} m for Choctawhatchee Bay, \Sexpr{maxs[maxs$seg == '820', 'maxs']} m for the Big Bend, and \Sexpr{maxs[maxs$seg == '1502', 'maxs']} m for the Indian River Lagoon segments.  However, most confidence intervals for the remaining grid locations were much smaller than the maximum in each segment.  A comparison of overlapping confidence intervals for $Z_{c,\,min}$, $Z_{c,\,med}$, and $Z_{c,\,max}$ at each grid location indicated that not every measure was unique.  Specifically, only \Sexpr{100 - overlap[overlap$seg == '303', 'overlapped']}\% of grid points in Choctawhatchee Bay and \Sexpr{100 - overlap[overlap$seg == '902', 'overlapped']}\% in Old Tampa Bay had significantly different estimates, whereas \Sexpr{100 - overlap[overlap$seg == '1502', 'overlapped']}\% of grid points in the Indian River Lagoon and \Sexpr{100 - overlap[overlap$seg == '820', 'overlapped']}\% of grid points in the Big Bend segments had estimates that were significantly different.  By contrast, all grid estimates in Choctawhatchee Bay and Indian River Lagoon had $Z_{c,\,max}$ estimates that were significantly greater than zero, whereas all but \Sexpr{nonsigs[nonsigs$seg == '902', 'ltzero']}\% of grid points in Old Tampa Bay and \Sexpr{nonsigs[nonsigs$seg == '820', 'ltzero']}\% of grid points in the Big Bend segment had $Z_{c,\,max}$ estimates significantly greater than zero. 

\subsection{Evaluation of seagrass light requirements}

<<echo = F>>=
# load data
data(irl_light)
data(tb_light)
irl <- data.frame(irl_light)
tb <- data.frame(tb_light)

# light between bays
light_btw <- t.test(tb$light, irl$light)

# light within bays
wtn_tb <- summary(lm(light ~ seg, data = tb))$fstatistic
wtn_tb <- c(wtn_tb, pf(wtn_tb[1], wtn_tb[2], wtn_tb[3],lower.tail=F))
names(wtn_tb) <- c('Fval', 'df1', 'df2', 'pval')
wtn_irl <- summary(lm(light ~ seg, data = irl))$fstatistic
wtn_irl <- c(wtn_irl, pf(wtn_irl[1], wtn_irl[2], wtn_irl[3],lower.tail=F))
names(wtn_irl) <- c('Fval', 'df1', 'df2', 'pval')

# tukey comps
tuk_tb <- aov(light ~ seg, data = tb)
tuk_tb <- TukeyHSD(tuk_tb)$seg[, 'p adj']
tuk_irl <- aov(light ~ seg, data = irl)
tuk_irl <- TukeyHSD(tuk_irl)$seg[, 'p adj']

@

% add some stuff about secchi here

Estimates of seagrass depth limits and corresponding light requirements for all segments of Tampa Bay and the Indian River Lagoon indicated substantial variation, both between and within the different bays (\cref{tab:secc_summ,fig:light_tb,fig:light_irl}).  Seagrass \ac{doc} estimates were obtained for \Sexpr{nrow(tb_light)} locations in Tampa Bay and \Sexpr{nrow(irl_light)} locations in the Indian River Lagoon where secchi observations were available in the Florida \ac{IWR} database.  Mean secchi depth for all recorded observations was \Sexpr{mean(tb$SD)} m ($n=$ \Sexpr{nrow(tb)}) for Tampa Bay and \Sexpr{mean(irl$SD)} m ($n=$ \Sexpr{nrow(irl)}) for Indian River Lagoon.  Mean light requirements were significantly different between the bays (two-sided t-test, $t=$ \Sexpr{light_btw$statistic}, $df=$ \Sexpr{light_btw$parameter}, $p < 0.001$) with a mean requirement of \Sexpr{mean(tb$light)}\% for Tampa Bay and \Sexpr{mean(irl$light)}\% for Indian River Lagoon.  Within each bay, light requirements were significantly different between segments (ANOVA, $F =$ \Sexpr{form_fun(wtn_tb['Fval'], 1, 1, 1)}, $df =$ \Sexpr{wtn_tb['df1']}, \Sexpr{wtn_tb['df2']}, $p = $ \Sexpr{form_fun(wtn_tb['pval'])} for Tampa Bay, $F =$ \Sexpr{form_fun(wtn_irl['Fval'], 1, 1, 1)}, $df =$ \Sexpr{wtn_irl['df1']}, \Sexpr{wtn_irl['df2']}, $p = $ \Sexpr{form_fun(wtn_irl['pval'], 3, 3, 3)} for Indian River Lagoon).  However, post-hoc evaluation of all pair-wise comparisons of mean light requirements indicated that significant differences were only observed between a few segments within each bay.  Significant differences in Tampa Bay were observed between Old Tampa Bay and Hillsborough Bay (Tukey multiple comparisons, $p =$ \Sexpr{form_fun(tuk_tb['OTB-HB'], 3, 3, 3)}).  Significant differences in the Indian River Lagoon were observed between the Upper Indian River Lagoon and Banana River ($p =$ \Sexpr{form_fun(tuk_irl['UIRL-BR'], 3, 3, 3)}), the Upper Indian River Lagoon and Lower Indian River Lagoon ($p =$ \Sexpr{form_fun(tuk_irl['UIRL-LIRL'], 3, 3, 3)}), and Upper Indian River Lagoon and Lower St. Lucie ($p =$ \Sexpr{form_fun(tuk_irl['UIRL-LSL'], 3, 3, 3)}) segments.  In general, spatial variation of light requirements in Tampa Bay suggested that seagrasses were less light-limited (i.e., lower percent light requirements at $Z_{c,\,max}$) in Hillsborough Bay and western areas of Lower Tampa Bay near the Gulf of Mexico (\cref{fig:light_tb}).  Seagrassess in the Indian River Lagoon were generally less light-limited towards the south and in the Banana River segment (\cref{fig:light_irl}).

\section{Discussion}

% note that outliers were removed for sensitivity (99th percentile) and all estimates

% Describe why estimates were unavailable in particular areas of each segment

% ability to create significantly different estimates for each segment - depends on slope, radius size

% Acknowledge that comparisons with segment wide estimate are specific to grid spacing and radii tha twere used, thus the comparison is only useful for illustrating the presence of heterogeneity within segments, as well as variation between segments.  Absolute values will vary with different spacing and radii. 

% estimates where there is no seagrass - what does this mean? how is this interpreted? 

% qualitative and quantitative advantages of the approach

% factors that influence seagrass growth patterns - not just limited to light (see main paper about this), also Kemp et al. 2004 intro and fig. 1

% why were light requirements higher in some areas (i.e., seagrasses not growing as deep as expected)?  epiphytic contributions (algae, detritus, sediment, etc.) - Kemp et al. 2004 - explain PLW and PLL in this context, if epiphyte load is low PLW = PLL

% generic products available from Hagy, method can be applied to these products

%%%%%%
% refs
\clearpage
\begin{singlespace}
\bibliographystyle{apalike_mine}
\bibliography{ref_sgdepth}
\end{singlespace}
\clearpage

%%%%%%
% tables

% summary of wbid characteristics
<<eval = T, echo = F>>=

# # create shapefile object of seagrass coverages
# id <- c('sg_2007_303.shp', 'sg_2006_820.shp', 'sg_2010_902.shp', 'sg_2009_1502.shp')
# sg_shps <- list()
# for(i in id){
#   
#   path <- paste0('M:/GIS/seagrass/', i)
#   sg <- readShapeSpatial(path)
#   sg_shps[[i]] <- sg
#   
# }
# save(sg_shps, file = 'data/sg_shps.RData')
# 
# # bathymetry data
# id <- c('dep_303.shp', 'dep_820.shp', 'dep_902.shp', 'dep_1502.shp')
# dep_shps <- list()
# for(i in id){
#   
#   cat(i, '\n')
#   path <- paste0('M:/GIS/seagrass/', i)
#   dep <- readShapeSpatial(path)
#   dep_shps[[i]] <- dep
#   
# }
# save(dep_shps, file = 'data/dep_shps.RData')
# 
# load(file = 'data/shps.RData')
# load(file = 'data/sg_shps.RData')
# load(file = 'data/secc_all.RData')
# load(file = 'data/dep_shps.RData')
# 
# nm <- c('Choctawhatchee Bay', 'Big Bend', 'Old Tampa Bay', 'Upper Indian River Lagoon')
# 
# # lat, long
# lat <- sapply(
#   c('seg_303.shp', 'seg_820.shp', 'seg_902.shp', 'seg_1502.shp'), 
#   function(x) data.frame(rgeos::gCentroid(shps[[x]]))[, 2]
# )
# lon <- sapply(
#   c('seg_303.shp', 'seg_820.shp', 'seg_902.shp', 'seg_1502.shp'), 
#   function(x) data.frame(rgeos::gCentroid(shps[[x]]))[, 1]
# )
# 
# # segment, seagrass, prop areas
# areas <- sapply(
#   c('303', '820', '902', '1502'), 
#   function(x){
#     
#     # data and projections
#     seg <- shps[[paste0('seg_', x, '.shp')]]
#     sg <- sg_shps[[grep(paste0(x, '\\.shp'), names(sg_shps))]]
#     proj4string(seg) <- CRS("+proj=longlat +datum=NAD83")
#     proj4string(sg) <- CRS("+proj=longlat +datum=NAD83")
#     
#     # proj for transformation
#     trans_proj <- CRS("+proj=utm +zone=17 +datum=NAD83")
#     if(x == '303') trans_proj <- CRS("+proj=utm +zone=16 +datum=NAD83")
#     seg <- spTransform(seg, trans_proj)  
#     sg <- spTransform(sg, trans_proj)
#     
#     # clip, get area in sq km
#     clip_sg <- gIntersection(sg, seg, byid = TRUE) #, drop_lower_td = TRUE)
#     seg_est <- gArea(seg)/1e6
#     sg_est <- gArea(clip_sg)/1e6
#     
#     # list output
#     c(seg_est, sg_est)
#       
#   })
# 
# # segment depths
# deps <- sapply(
#   c('303', '820', '902', '1502'), 
#   function(x){
#     
#     tmp <- dep_shps[[paste0('dep_', x, '.shp')]]
#     nm <- c('depth', 'GRID_CODE', 'Depth')
#     nm <- names(tmp)[names(tmp) %in% nm]
#     tmp <- -1 * data.frame(tmp)[, nm, drop = T]
#     
#     tmp <- tmp[tmp <= quantile(tmp, 0.99)]
#     mn_val <- mean(tmp, na.rm = T)
#     max_val <- max(tmp, na.rm = T)
#   
#     c(mn_val, max_val)
#     
#   })
# 
# # segment secchi
# seccs <- sapply(
#   c('303', '820', '902', '1502'), 
#   function(x){
#     
#     # subset secchi
#     seg <- shps[[paste0('seg_', x, '.shp')]]
#     secc <- !is.na(secc_all %over% seg)[, 1]
#     secc <- secc_all[secc, ]
#     secc$yr <- as.numeric(strftime(secc$Date, '%Y'))
#     
#     # subset by most recent ten years
#     yr_vals <- data.frame(
#       seg = c('303', '820', '902', '1502'), 
#       yrs = c(2007, 2006, 2010, 2009)
#       )
#     yr <- yr_vals[yr_vals$seg == x, 'yrs']
#     secc <- secc[secc$yr > yr - 10 & secc$yr <= yr, ]
#     
#     # mean secchi and n
#     ave_secc <- mean(as.numeric(secc$SD), na.rm = T)
#     se_secc <- sd(as.numeric(secc$SD), na.rm = T)/sqrt(length(na.omit(secc$SD)))
#       
#     c(ave_secc, se_secc)
#     
#   })
# # fill in 820 manually, data are from elsewhere
# seccs[, 2] <- c(1.34, 0.19)
# 
# # combine data
# out <- data.frame(rbind(lat, lon, areas, deps, seccs), stringsAsFactors = F)
# names(out) <- nm
# row.names(out) <- c('Latitude', 'Longitude', 'Surface area', 'Seagrass area', 'Depth (mean)', 'Depth (max)', 'Secchi (mean)', 'Secchi (se)')
#   
# seg_summ <- out
# save(seg_summ, file = 'data/seg_summ.RData')

load(file = 'data/seg_summ.RData')

# rearrange col orders for alphabetical
seg_summ <- seg_summ[, order(names(seg_summ))]

# prep table
tab <- seg_summ
nms <- names(tab)
tab <- data.frame(apply(tab, 2, form_fun), stringsAsFactors = F)
tab<- rbind(year = c('2006', '2007', '2010', '2009'), tab)
names(tab) <- nms
rows <- c('Year\\textsuperscript{\\textit{a}}', 'Latitude', 'Longitude', 'Surface area', 'Seagrass area', 'Depth (mean)', 'Depth (max)', 'Secchi (mean)', 'Secchi (se)')

# shorten uirl name
names(tab) <- gsub('River', 'R.', names(tab))

cap.val <- "Characteristics of coastal segments used to evaluate seagrass \\acl{doc} estimates (see \\cref{fig:seg_all} for spatial distribution).  Year is the date of the seagrass coverage and bathymetric data.  Latitude and longitude are the geographic centers of each segment.  Area and depth values are meters and square kilometers, respectively.  Secchi measurements (m) were obtained from the Florida Department of Environmental Protection's \\acl{IWR} (\\acs{IWR}) database, update number 40.  Secchi mean and standard errors are based on all observations within the ten years preceding each seagrass survey."

foot.val <- '\\footnotesize \\textsuperscript{\\textit{a}} Seagrass coverage data sources, see \\cref{sec:data_srcs} for bathymetry data sources:\\scriptsize\\\\Big Bend: \\url{http://atoll.floridamarine.org/Data/metadata/SDE_Current/seagrass_bigbend_2006_poly.htm}\\\\Choctawhatchee Bay: \\url{http://atoll.floridamarine.org/data/metadata/SDE_Current/seagrass_chotawhatchee_2007_poly.htm}\\\\Tampa Bay: \\url{http://www.swfwmd.state.fl.us/data/gis/layer_library/category/swim}\\\\Indian R. Lagoon: \\url{http://www.sjrwmd.com/gisdevelopment/docs/themes.html}'

latex( 
  tab,
  file = '',
  rowlabel = '',
  caption = cap.val,
  caption.loc = 'top',
  insert.bottom = foot.val, 
  rowname = rows,
  label = 'tab:seg_summ'
  )

@

% comparisons with segment wide ests
<<eval = T, echo = F>>=

# ##
# # get doc ests for whole seg
# 
# load('data/shps.RData')
# 
# segs <- c('303', '820', '902', '1502')
# 
# ests_seg <- vector('list', length = length(segs))
# names(ests_seg) <- segs
# 
# for(seg in segs){
#     
#   seg_shp <- shps[[paste0('seg_', gsub('^.*_', '', seg), '.shp')]]
#   sgpts_shp <- shps[[grep(paste0('^sgpts.*', seg, '.shp$'), names(shps))]]
#   
#   rad <- 0.25 # sufficient for each seg
#   test_loc <- rgeos::gCentroid(seg_shp)
#   ests <- doc_est_grd(test_loc, sgpts_shp, radius = rad)
# 
#   ests_seg[[seg]] <- data.frame(ests, seg = seg)
#   
# }
# 
# ests_seg <- do.call('rbind', ests_seg)
# names(ests_seg)[names(ests_seg) %in% c('x', 'y')] <- c('long', 'lat')
# 
# save(ests_seg, file = 'data/ests_seg.RData')
# 
# # get estimates for grids
# ests_out <- vector('list', length = length(segs))
# names(ests_out) <- segs
# 
# for(seg in segs){
#     
#   seg_shp <- shps[[paste0('seg_', gsub('^.*_', '', seg), '.shp')]]
#   sgpts_shp <- shps[[grep(paste0('^sgpts.*', seg, '.shp$'), names(shps))]]
#   
#   grid_spc <- 0.01
#   rad <- 0.02
#   grid_seed <- 4321
#   set.seed(grid_seed)
#   pts <- grid_est(seg_shp, spacing = grid_spc) 
#   ests <- doc_est_grd(pts, sgpts_shp, radius = rad, out_sens = T, remzero = F)
# 
#   ests_out[[seg]] <- data.frame(ests, seg = seg)
#   
# }
# 
# ests_out <- do.call('rbind', ests_out)
# names(ests_out)[names(ests_out) %in% c('Var1', 'Var2')] <- c('long', 'lat')
# 
# # get ci size, these are all the same for each measure
# # get lower bound of z_cmax for eval of those greater than zero
# ests_out$confint <- with(ests_out, h_z_cmin - l_z_cmin)
# ests_out$lower_max <- ests_out$l_z_cmax
# ests_out <- ests_out[, !grepl('^h_|^l_', names(ests_out))]
# 
# # remove outliers from ests based on 99%
# ests <- ests_out[, c('z_cmin', 'z_cmed', 'z_cmax')]
# filt_val <- quantile(unlist(c(ests)), 0.99)
# ests[ests > filt_val] <- NA
# ests_out[, c('z_cmin', 'z_cmed', 'z_cmax')] <- ests
# ests_out <- na.omit(ests_out)
# 
# ests_out_nonsigs <- ests_out
# ests_out <- ests_out[ests_out$lower_max >= 0, ]
# 
# save(ests_out_nonsigs, file = 'data/ests_out_nonsigs.RData')
# save(ests_out, file = 'data/ests_out.RData')

# load data
load(file = 'data/ests_seg.RData')
load(file = 'data/ests_out.RData')

# rearrange row orders for alphabetical
segs <- c('CB', 'BB', 'OTB', 'UIRL')
levels(ests_seg$seg) <- segs
ests_seg$seg <- as.character(ests_seg$seg)
ests_seg <- ests_seg[order(ests_seg$seg), ]
levels(ests_out$seg) <- segs
ests_out$seg <- as.character(ests_out$seg)
ests_out <- ests_out[order(ests_out$seg), ]
segs <- sort(segs)

# summarize spatail ests
ests_out <- melt(ests_out, measure.var = c('z_cmin', 'z_cmed', 'z_cmax'))
ests_out <- ddply(ests_out, .variable = c('seg', 'variable'),   
  .fun = function(x) {
    c(mean_val = mean(x$value),
    sd_val = sd(x$value),
    min_val = min(x$value),
    max_val = max(x$value)
    )
  })

# merge with segment wide ests
ests_seg <- melt(ests_seg, measure.var = c('z_cmin', 'z_cmed', 'z_cmax'))
to_tab <- merge(ests_seg[, c('seg', 'variable', 'value')], ests_out, by = c('seg', 'variable'))
to_tab$variable <- factor(to_tab$variable, levels = c('z_cmin', 'z_cmed', 'z_cmax'))
to_tab <- to_tab[order(to_tab$seg, to_tab$variable), ]
names(to_tab) <- c('Segment', 'Estimate', 'Whole segment', 'Mean', 'St. Dev.', 'Min', 'Max')

# prep table
estimate <- to_tab$Estimate
estimate <- factor(estimate, levels = c('z_cmin', 'z_cmed', 'z_cmax'), 
  labels = c('$Z_{c,\\,min}$', '$Z_{c,\\,med}$', '$Z_{c,\\,max}$'))
nms <- names(to_tab)[-c(1, 2)]
tab <- to_tab[, !names(to_tab) %in% c('Segment', 'Estimate')]

tab <- data.frame(apply(tab, 2, form_fun), stringsAsFactors = F)
names(tab) <- nms

foot.val<-'\\textsuperscript{\\textit{a}}\\footnotesize BB: Big Bend, CB: Choctawhatchee Bay, OTB: Old Tampa Bay, UIRL: Upper Indian River Lagoon.' 

cap.val <- "Summary of seagrass depth estimates (m) for each segment using all grid locations in \\cref{fig:all_ests}.  Whole segment estimates were obtained from all seagrass depth data for each segment."

latex(
  tab,
  file = '',
  rowlabel = '{\\bf Segment\\textsuperscript{\\textit{a}}}',
  caption = cap.val,
  dcolumn = T,
  caption.loc = 'top',
  rgroup = segs,
  n.rgroup = rep(3,4),
  insert.bottom = foot.val,
  rowname = estimate,
  label = 'tab:est_summ'
  )

@

% summary of sensitivity analysis
<<eval = T, echo = F>>=

# load data
data(shps)
data(ests_out)

# summarize 
to_tab <- group_by(ests_out, seg) %>% 
  summarize(
    `Mean` = mean(confint),
    `St. Dev` = sd(confint), 
    `Min` = min(confint), 
    `Max` = max(confint)
    )

# prep table
segs <- c('CB', 'BB', 'OTB', 'UIRL')
tab <- select(to_tab, -seg)
nms <- names(tab)
tab <- data.frame(apply(tab, 2, form_fun), stringsAsFactors = F)
names(tab) <- nms

cap.val <- "Summary of uncertainty for seagrass depth estimates (m) for each segment using all grid locations in \\cref{fig:all_sens}.  The uncertainty values are equally applicaable to each seagrass depth measure ($Z_{c,\\,min}$, $Z_{c,\\,med}$, $Z_{c,\\,max}$)."

foot.val<-'\\textsuperscript{\\textit{a}}\\footnotesize BB: Big Bend, CB: Choctawhatchee Bay, OTB: Old Tampa Bay, UIRL: Upper Indian River Lagoon.' 

col_heads <- c('Min year', 'Max year', '$n_{Secchi}$', '$n_{Z}$', 'Secchi', '$Z_{c,\\,max}$', '\\% light')

# rearrange row orders for alphabetical
arr <- order(segs)
segs <- segs[arr]
tab <- tab[arr, ]

# output
latex(
  tab,
  file = '',
  rowlabel = 'Segment\\textsuperscript{\\textit{a}}',
  caption = cap.val,
  dcolumn = T,
  caption.loc = 'top',
  rowname = segs,
  insert.bottom = foot.val,
  label = 'tab:sens_summ'
  )

@

% summary of light requirements analysis
<<eval = T, echo = F>>=

# ##
# # load data
# 
# # load results from figure chunks
# data(tb_light)
# data(irl_light)
# 
# # segment shapefiles
# data(tb_seg)
# data(irl_seg)
#  
# # all secchi data
# data(secc_all)
# 
# ##
# # prep data
# 
# # add yrs to secc_all
# secc_all$yr <- as.numeric(strftime(secc_all$Date, '%Y'))
# 
# # remove stations with less than five observations
# rems <- table(secc_all$Station_ID)
# rems <- names(rems)[rems < 5]
# secc_all <- secc_all[!secc_all$Station_ID %in% rems, ]
# 
# # clip secchi by tampa bay and irl segments
# # retain data within ten years of seagrass survey (2010 for TB, 2009 for IRL)
# sel_tb <- !is.na(secc_all %over% tb_seg)[, 1]
# sel_tb <- sel_tb & secc_all$yr > 2000 & secc_all$yr <= 2010
# sel_irl <- !is.na(secc_all %over% irl_seg)[, 1]
# sel_irl <- sel_irl & secc_all$yr > 1999 & secc_all$yr <= 2009
# sel_all <- apply(cbind(sel_tb, sel_irl), 1, any)
# secc_segs <- secc_all[sel_all, ]
# 
# # create bay column, only populate for TB
# # IRL will populate  in segment assignments
# secc_segs$bay <- 'TB'
# 
# # get segment for each point, TB
# for(seg in as.character(tb_seg$seg)){
#   
#   to_sel <- tb_seg[tb_seg$seg %in% seg, ]
#   sel <- !is.na(secc_segs %over% to_sel)[, 1]
#   secc_segs[sel, 'seg'] <- as.character(seg)
#   
# }
# 
# # get segment for each point, IRL
# for(seg in as.character(irl_seg$seg)){
#   
#   to_sel <- irl_seg[irl_seg$seg%in% seg, ]
#   sel <- !is.na(secc_segs %over% to_sel)[, 1]
#   secc_segs[sel, 'seg'] <- as.character(seg)
#   secc_segs$bay[sel] <- 'IRL'
#   
# }
# 
# ##
# # summarize secchi
# secc_summ <- data.frame(secc_segs) %>% 
#   group_by(bay, seg) %>% 
#   summarize(
#     min_date = min(Date), 
#     max_date = max(Date),
#     n_secchi = length(as.numeric(SD)),
#     mean_sd = mean(as.numeric(SD))
#   )
# 
# # summarize light requirements
# irl_summ <- data.frame(irl_light) %>% 
#   group_by(seg) %>% 
#   summarize(
#     n_locs = length(Station_ID), 
#     mean_z_cmax = mean(z_c_all), 
#     mean_light = mean(light)
#   )
# 
# tb_summ <- data.frame(tb_light) %>% 
#   group_by(seg) %>% 
#   summarize(
#     n_locs = length(Station_ID), 
#     mean_z_cmax = mean(z_c_all), 
#     mean_light = mean(light)
#   )
# 
# # combine all, remove LHR segment (crap data)
# secc_summ <- left_join(secc_summ, rbind_all(list(tb_summ, irl_summ)), by = 'seg') %>% 
#   filter(seg != 'LHR')
# 
# save(secc_summ, file = 'data/secc_summ.RData')

# load data
# note that the secchi summaries are based on all secchi for each bay
# irl, tb summaries are based on removal of extremes
data(secc_summ)

# prep for table
tab <- data.frame(secc_summ)
tab$min_date <- strftime(tab$min_date, '%Y')
tab$max_date <- strftime(tab$max_date, '%Y')
rows <- as.character(tab$seg)
tab <- tab[, -c(1:2)]
tab[, c(4, 6:7)] <- formtab_fun(tab[, c(4, 6:7)])

cap.val<-'Summary of water clarity data ($Z_{secchi}$), depth of colonization ($Z_{c,\\,max}$), and estimated light requirements for bay segments with available data for the Indian River Lagoon and Tampa Bay.  Water clarity data were obtained from secchi observations in the Florida \\acl{IWR} database for all available locations and dates within ten years of the seagrass survey in each bay.  Values are minimum and maximum years of secchi data, sample size of secchi data ($n_{Z_{secchi}}$), mean values (m) of secchi data, sample size of seagrass depth estimates ($n_{Z_{c,\\,max}}$) at each unique secchi location, mean $Z_{c,\\,max}$, and estimated \\% light requirements for each segment.  See \\cref{fig:light_irl,fig:light_tb} for spatial distribution of the results.'

foot.val<-'\\textsuperscript{\\textit{a}}\\footnotesize BR: Banana R., LCIRL: Lower Central Indian R. Lagoon, LIRL: Lower Indian R. Lagoon, LML: Lower Mosquito Lagoon, LSL: Lower St. Lucie, UCIRL: Upper Central Indian R. Lagoon, UIRL: Upper Indian R. Lagoon, UML: Upper Mosquito Lagoon, HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.' 
col_heads <- c('Min year', 'Max year', '$n_{Z_{secchi}}$', '$Z_{secchi}$', '$n_{Z_{c,\\,max}}$', '$Z_{c,\\,max}$', '\\% light')

latex( 
  tab,
  file = '',
  rowlabel = 'Segment\\textsuperscript{\\textit{a}}',
  rgroup = c('Indian River Lagoon', 'Tampa Bay'), 
  n.rgroup = c(8, 4),
  insert.bottom = foot.val,
  caption = cap.val,
  colheads = col_heads,
  caption.loc = 'top',
  rowname = rows,
  label = 'tab:secc_summ'
  )

@

\clearpage

%%%%%%
% figures

% example of buffer points for depth of col
<<buff_ex, cache = T, fig = F, echo = F, eval = T, message = F, results = 'hide', include = F>>=
########

# reset digits
options(digits = 4)

# load data, buff_ex_dat was created from various shapefiles
data(buff_ex_dat)
seg <- buff_ex_dat[['seg']] # 820 segment polygon
state <- buff_ex_dat[['state']] # florida state polygon
sgpoly <- buff_ex_dat[['sgpoly']] # 820 segment seagrass polygon
sgrass <- buff_ex_dat[['sgrass']] # 820 segment seagrass depth point
depths <- buff_ex_dat[['depths']] # 820 segment bathymetry dem, for contour lines
rm('buff_ex_dat')

# get a subsample of seagrass depth points for plotting
set.seed(4321)

est_pts <- grid_est(seg, spacing = 0.02)
sgrass <- sgrass[sample(1:length(sgrass), 1000), ]
test_pt <- est_pts[27, ]
buff_pts <- buff_ext(sgrass, test_pt, buff = 0.02)

# format buff_pts and sgrass for plotting
buff_pts <- data.frame(buff_pts)
levels(buff_pts$Seagrass) <- c('Seagrass present', 'Seagrass present', 'Seagrass absent')
buff_pts$Seagrass <- as.character(buff_pts$Seagrass)
sgrass <- data.frame(sgrass)
levels(sgrass$Seagrass) <- c('Seagrass present', 'Seagrass present', 'Seagrass absent')
sgrass$Seagrass <- as.character(sgrass$Seagrass)

# segment wide est for zcmax (all cats) for 820 from Hagy is 3.855
# get contour lines from bathymetry layer, one for whole segment and one for limit
to_cont <- seq(1, 15, by = 2)
im <- as.image.SpatialGridDataFrame(depths)
conts <- contourLines(im, levels = -1 * to_cont)
conts <- ContourLines2SLDF(conts)
zc_conts <- contourLines(im, levels = -3.855)
zc_conts <- ContourLines2SLDF(zc_conts)

# seagrass and depth contours
p1 <- ggplot(state, aes(long, lat, group = group)) + 
  geom_polygon(fill = 'lightgrey') +
  geom_polygon(data = seg, fill = 'white', col = 'black', aes(size = 'Segment polygon')) + 
  geom_polygon(data = sgpoly, aes(group = group, fill = 'Seagrass coverage'), 
    alpha = 0.7) + 
  geom_polygon(data = state, aes(group = group), 
    fill = 'grey') + 
  geom_path(data = conts, 
    aes(group = group, linetype = 'dashed')
    ) + 
  geom_path(data = zc_conts, 
    aes(group = group, colour = 'Estimated depth\nlimit for segment'), 
    size = 2
    ) +
  scale_fill_manual(values = 'royalblue') + 
  scale_colour_manual(
    values = 'red'
    ) +
  scale_size_manual('', values = 2) +
  scale_linetype_manual(labels = '2 m depth contours', values = 'dashed') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  coord_map(
    xlim = c(-83.65, -83.35),
    ylim = c(29.4, 29.8)
  ) +
  theme(axis.text = element_text(size = 10),
    axis.title = element_text(size = 20), 
    legend.text = element_text(size = 20),
    legend.title = element_blank()
  ) + 
  guides(fill = guide_legend(order = 1), 
    linetype = guide_legend(order = 2), 
    colour = guide_legend(order = 3)
  )

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none')

p2 <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black', size = 2) +
  geom_polygon(data = state, aes(group = group), fill = 'lightgrey') + 
  xlab('Longitude') +
  ylab('Latitude') +
  geom_point(
    data = data.frame(sgrass), 
    aes(x = coords_x1, y = coords_x2, shape = Seagrass), col = 'royalblue'
    ) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), size = 3, pch = 21, col = 'black', bg = 'white'
  ) +  
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), size = 17, pch = 1, colour = 'grey60'
  ) +
  scale_shape_manual('', values = c(2, 16)) +
  coord_equal() +
  coord_map(
    xlim = c(-83.65, -83.35),
    ylim = c(29.4, 29.8)
    ) + 
  theme_classic() +
  theme(axis.text = element_text(size = 10),
    legend.text = element_text(size = 20),
    axis.title = element_text(size = 20)
    )

p2leg <- g_legend(p2)
p2 <- p2 + theme(legend.position = 'none')

p3 <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black', size = 2) +
  geom_polygon(data = state, aes(group = group), fill = 'lightgrey') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  coord_map(
    xlim = c(-83.65, -83.35),
    ylim = c(29.4, 29.8)
    ) +
  geom_point(
    data = buff_pts,
    aes(coords.x1, coords.x2, pch = Seagrass), 
    colour = 'royalblue'
  ) + 
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2), colour = 'black', bg = 'white', size = 3, pch = 21
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2), colour = 'red', size = 5, pch = 16
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2), size = 17, pch = 1, colour = 'grey60'
  ) +
  scale_shape_manual('', values = c(2, 16)) +
  theme(axis.text = element_text(size = 10),
    legend.text = element_text(size = 20), 
    axis.title = element_text(size = 20), 
    legend.position = 'none')

pleg <- ggplot(seg, aes(long, lat)) + 
  geom_polygon(fill = 'white') +
  geom_path(color = 'black') +
  theme_classic() +
  coord_equal() +
  xlab('Longitude') +
  ylab('Latitude') +
  scale_x_continuous(limits = c(-83.65, -83.35)) +
  scale_y_continuous(limits = c(29.4, 29.8)) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2, colour = 'grid', size = 'grid', pch = 'grid'),
  ) +
  geom_point(
    data = data.frame(test_pt),
    aes(Var1, Var2, colour = 'test', size = 'test', pch = 'test'),
  ) +
  geom_point(
    data = data.frame(est_pts), 
    aes(Var1, Var2, size = 'rad', pch = 'rad', colour = 'rad'),
  )  +
  scale_colour_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c('black', 'red', 'grey60')) +
  scale_size_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c(3, 4, 10)) +
  scale_shape_manual('', labels = c('Estimation grid', 'Test point', 'Sample area'), values = c(1, 16, 1)) +
theme(axis.text = element_text(size = 20),
  legend.text = element_text(size = 20),
  axis.title = element_text(size = 20)
  )

pleg <- g_legend(pleg)

pdf('figs/buff_ex.pdf', height = 6, width = 6, family = 'serif')
p1
p2
p3
grid.arrange(p1leg, p2leg, pleg, heights = c(1, 0.6, 0.6), ncol = 1)
dev.off()
   
options(digits = 2)
@

% example of buffer points for depth of col
\begin{figure}
\centering
\subfloat[][Seagrass coverage and bathymetry for the segment]{
\includegraphics[width=0.5\textwidth,page=1]{figs/buff_ex.pdf}
\label{fig:buff_ex1}
}
\subfloat[][Grid of locations and sample areas for estimates]{
\includegraphics[width=0.5\textwidth,page=2]{figs/buff_ex.pdf}
\label{fig:buff_ex2}
}

\subfloat[][Sampled seagrass data for a test point]{
\includegraphics[width=0.5\textwidth,page=3]{figs/buff_ex.pdf}
\label{fig:buff_ex3}
}
\subfloat{
\includegraphics[width=0.5\textwidth,page=4]{figs/buff_ex.pdf}
}
\caption{Examples of data and grid locations for estimating seagrass depth of colonization for a region of the Big Bend, Florida.  \Cref{fig:buff_ex1} shows the seagrass coverage and depth contours at 2 meter intervals, including the whole segment estimate for depth of colonization. \cref{fig:buff_ex2} shows a grid of sampling locations with sampling radii for estimating \ac{doc} and seagrass depth points derived from bathymetry and seagrass coverage layers.  \cref{fig:buff_ex3} shows an example of sampled seagrass depth points for a test location.  Estimates in \cref{fig:est_ex} were obtained from the test location in \cref{fig:buff_ex3}.}
\label{fig:buff_ex}
\end{figure}

% example of depth of col ests for wbid - big bend 820
\begin{figure}
\centerline{\includegraphics[width = \textwidth]{figs/seg_all.pdf}}
\caption{Locations and seagrass coverage of estuary segments used to evaluate \acl{doc} estimates.  Seagrass coverage layers are from 2007 (CB: Choctawhatchee Bay), 2006 (BB: Big Bend), 2010 (OTB: Old Tampa Bay), and 2009 (UIRL: Upper Indian R. Lagoon).}
\label{fig:seg_all}
\end{figure}

% example of estimating seagrass depth of colonization
<<est_ex, cache = T, echo = F, results = 'hide', eval = T>>=

data(shps)

seg <- shps[['seg_820.shp']] # 820 segment polygon
sgrass <- shps[['sgpts_2006_820.shp']] # 820 segment seagrass depth point
# sgrass <- sgrass[sample(1:nrow(sgrass), 2000, replace = F),]

set.seed(4321)
est_pts <- grid_est(seg, spacing = 0.02)
test_pt <- est_pts[27, ]

buff_pts <- buff_ext(sgrass, test_pt, buff = 0.02)

doc_in <- data.frame(buff_pts)
dat <- doc_est(doc_in)

##
# plots 

# base plot if no estimate is available
pa <- plot(dat, baseonly = T)

# base plot with logistic curve
pb <- plot(dat, logisonly = T)
  
# complete plot
pc <- plot(dat)

pdf('figs/est_ex.pdf', height = 4.5, width = 8.5, family = 'serif')

print(pa)
print(pb)
print(pc)

dev.off()
    
@

% example of depth of col ests for wbid - big bend 820
\begin{figure}
\centering
\subfloat[][Proportion of points with seagrass by depth]{
\includegraphics[page=1,width=0.5\textwidth]{figs/est_ex.pdf}
\label{fig:est_ex1}
}

\subfloat[][Logistic growth curve fit through points]{
\includegraphics[page=2,width=0.5\textwidth]{figs/est_ex.pdf}
\label{fig:est_ex2}
}

\subfloat[][Depth estimates]{
\includegraphics[page=3,width=0.5\textwidth]{figs/est_ex.pdf}
\label{fig:est_ex3}
}
\caption{Methods for estimating seagrass depth of colonization using sampled seagrass depth points around a single location. \Cref{fig:est_ex1} is the proportion of points with seagrass by depth using depth points within the buffer of the test point in \cref{fig:buff_ex}.  \Cref{fig:est_ex2} adds a decreasing logistic growth curve fit through the points.  \Cref{fig:est_ex3} shows three depth estimates based on a linear curve fit through the inflection point of logistic growth curve.}
\label{fig:est_ex}
\end{figure}

% grid examples for each segment
<<all_ests, echo = F, cache = T, results = 'hide', eval = T>>=

##
# load data
# ests out created in chunk for table 'tab:est_summ'
data(shps)
data(ests_out)

##
# make plots

# color function
col_fun <- function(x, cols = c('blue', 'lightblue', 'yellow', 'brown')){
  vals_in <- scales::rescale(x, c(0, 1))
  dim_vals <- dim(vals_in)
  nms <- names(vals_in)
  ramp <- colorRamp(cols)
  cols <- ramp(unlist(c(vals_in)))
  col <- rgb(cols, max = 255)
  out <- matrix(col, ncol = dim_vals[2], nrow = dim_vals[1], byrow = F)
  out <- data.frame(out, stringsAsFactors = F)
  names(out) <- nms
  return(out)
}

# segments for plotting
all_segs <- shps[grepl('^seg_', names(shps))]
all_segs <- lapply(all_segs, fortify)
all_segs <- do.call('rbind', all_segs)
all_segs$group <- gsub('^seg_|\\.shp\\.[0-9]*$', '', row.names(all_segs))
all_segs$group <- factor(all_segs$group, levels = c('1502', '303', '820', '902'), 
  labels = c('UIRL', 'CB', 'BB', 'OTB'))
all_segs$group <- as.character(all_segs$group)
levs <- sort(unique(all_segs$group))

levels(ests_out$seg) <- c('CB', 'BB', 'OTB', 'UIRL')

# assign plots by segment and doc est
for(i in 1:length(levs)){
  
  # subset segment shapefiles and ests by segment
  seg_sub <- all_segs[all_segs$group %in% levs[i], ]
  est_sub <- ests_out[ests_out$seg %in% levs[i], ]
  
  # scale for sizing
  scls <- c(1, 6)
  scl_vals <- scales::rescale(est_sub[, c('z_cmin', 'z_cmed', 'z_cmax')], to = scls)

  # scale for colour
  col_vals <- col_fun(scl_vals)
  pt_plo <- data.frame(est_sub[, c('seg', 'long', 'lat')], scl_vals, col_vals)
  
  # segment base plot
  p_seg <- ggplot(seg_sub, aes(x = long, y = lat)) +
    geom_polygon(fill = NA, colour = 'black') + 
    coord_fixed() +
    theme_classic() +
    theme(axis.title = element_blank(), axis.text = element_text(size = 6), 
      axis.text.x = element_text(angle = 90, vjust = 0.5),
      plot.margin=unit(c(0, 0, 0, 0), "cm")) + 
    scale_x_continuous(labels = fmt()) + 
    scale_y_continuous(labels = fmt())
  
  # z_cmin
  
  pt_sz <- 2
  
  pa <- p_seg +
    geom_point(data = pt_plo, aes(x = long, y = lat), colour = pt_plo$z_cmin.1, 
      size = pt_sz) 

  # z_cmed
  pb <- p_seg +
    geom_point(data = pt_plo, aes(x = long, y = lat), colour = pt_plo$z_cmed.1, 
      size = pt_sz)

  # z_cmax
  pc <- p_seg +
    geom_point(data = pt_plo, aes(x = long, y = lat), colour = pt_plo$z_cmax.1,
      size = pt_sz) 
  
  # legend for all three
  leg_plo <- est_sub[, !names(est_sub) %in% c('seg', 'confint')]
  leg_plo <- melt(leg_plo, id.var = c('long', 'lat'))
  
  leg_brks <- seq(min(leg_plo$value, na.rm =  T), max(leg_plo$value, na.rm = T), length = 4)
  leg_labs <- form_fun(leg_brks, 1, 1, 1)
  
  pleg <- p_seg +
    geom_point(data = leg_plo, 
      aes(x = jitter(long), y = jitter(lat), colour = value)) +
    scale_colour_gradientn(name = levs[i], colours = eval(formals(col_fun)$cols),
      breaks = leg_brks, labels = leg_labs) +
    guides(colour = guide_legend(), size = guide_legend())
  pleg <- g_legend(pleg)
   
  # assign to global
  assign(paste0('pa', i), pa)
  assign(paste0('pb', i), pb)
  assign(paste0('pc', i), pc)
  assign(paste0('pleg', i), pleg)
}

# labels
lab1 <- expression(italic(Z ['c, min']))
lab2 <- expression(italic(Z ['c, med']))
lab3 <- expression(italic(Z ['c, max']))

# arrange all as grob
grobwidths <- c(1, 1, 1, 0.3)

pdf('figs/all_ests.pdf', height = 9, width = 7, family = 'serif')
grid.arrange(
  arrangeGrob(textGrob(lab1), textGrob(lab2), textGrob(lab3), textGrob(''), ncol = 4, widths = grobwidths), 
  arrangeGrob(pa1, pb1, pc1, pleg1, ncol = 4, widths = grobwidths),
  arrangeGrob(pa2, pb2, pc2, pleg2, ncol = 4, widths = grobwidths),
  arrangeGrob(pa3, pb3, pc3, pleg3, ncol = 4, widths = grobwidths),
  arrangeGrob(pa4, pb4, pc4, pleg4, ncol = 4, widths = grobwidths),
  ncol = 1, heights = c(0.1, 0.75,1,1,1.25)
)
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/all_ests.pdf}
\caption{Spatially-resolved estimates of seagrass depth limits (m) for four coastal segments of Florida.  Estimates include minimum ($Z_{c,\,min}$), median ($Z_{c,\,med}$), and maximum depth of colonization ($Z_{c,\,max}$).  Estimates are assigned to grid locations for each segment, where grid spacing was fixed at 0.02 decimal degrees.  Radii for sampling seagrass bathymetric data around each grid location were fixed at 0.06 decimal degrees. BB: Big Bend, CB: Choctawhatchee Bay, OTB: Old Tampa Bay, UIRL: Upper Indian R. Lagoon.}
\label{fig:all_ests}
\end{figure}

% range of confidence intervals for estimates
<<all_sens, echo = F, cache = T, results = 'hide', eval = T>>=

##
# ests out created in chunk for table 'tab:est_summ'
data(shps)
data(ests_out)

##
# make plots

# color function
col_fun <- function(x, cols = c('blue', 'lightblue', 'yellow', 'brown')){
  vals_in <- scales::rescale(x, c(0, 1))
  dim_vals <- dim(vals_in)
  nms <- names(vals_in)
  ramp <- colorRamp(cols)
  cols <- ramp(unlist(c(vals_in)))
  col <- rgb(cols, max = 255)
  out <- matrix(col, ncol = dim_vals[2], nrow = dim_vals[1], byrow = F)
  out <- data.frame(out, stringsAsFactors = F)
  names(out) <- nms
  return(out)
}

# segments for plotting
all_segs <- shps[grepl('^seg_', names(shps))]
all_segs <- lapply(all_segs, fortify)
all_segs <- do.call('rbind', all_segs)
all_segs$group <- gsub('^seg_|\\.shp\\.[0-9]*$', '', row.names(all_segs))
all_segs$group <- factor(all_segs$group, levels = c('1502', '303', '820', '902'), 
  labels = c('UIRL', 'CB', 'BB', 'OTB'))
all_segs$group <- as.character(all_segs$group)
levs <- sort(unique(all_segs$group))

levels(ests_out$seg) <- c('CB', 'BB', 'OTB', 'UIRL')

# assign plots by segment and doc est
for(i in 1:length(levs)){
  
  # subset segment shapefiles and ests by segment
  seg_sub <- all_segs[all_segs$group %in% levs[i], ]
  est_sub <- ests_out[ests_out$seg %in% levs[i], ]
  
  # scale for sizing
  scls <- c(1, 6)
  scl_vals <- scales::rescale(est_sub[, c('confint'), drop = F], to = scls)

  # scale for colour
  col_vals <- col_fun(scl_vals)
  pt_plo <- data.frame(est_sub[, c('seg', 'long', 'lat')], scl_vals, col_vals)
  
  # segment base plot
  p_seg <- ggplot(seg_sub, aes(x = long, y = lat)) +
    geom_polygon(fill = NA, colour = 'black') + 
    coord_fixed() +
    theme_classic() +
    theme(axis.title = element_blank(), axis.text = element_text(size = 6), 
      axis.text.x = element_text(angle = 90, vjust = 0.5),
      plot.margin=unit(c(0, 0, 0, 0), "cm")) +
    scale_x_continuous(labels = fmt()) + 
    scale_y_continuous(labels = fmt())
  
  # add sens points
  pt_sz = 2
  
  p <- p_seg +
    geom_point(data = pt_plo, aes(x = long, y = lat), colour = pt_plo$confint.1,
      size = pt_sz) 
  
  # legend
  leg_brks <- seq(min(est_sub$confint, na.rm =  T), max(est_sub$confint, na.rm = T), length = 4)
  leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
  pleg <- p_seg +
    geom_point(data = est_sub, aes(x = jitter(long), y = jitter(lat), colour = confint)) +
    scale_colour_gradientn(name = levs[i], colours = eval(formals(col_fun)$cols),
      breaks = leg_brks, labels = leg_labs) +
    guides(colour = guide_legend(), size = guide_legend())
  pleg <- g_legend(pleg)
   
  # assign to global
  assign(paste0('p', i), p)
  assign(paste0('pleg', i), pleg)
}

# labels
# arrange all as grob
grobwidths <- c(1, 0.3)

pdf('figs/all_sens.pdf', height = 7, width = 7, family = 'serif')
grid.arrange(
  arrangeGrob(p1, pleg1, ncol = 2, widths = grobwidths),
  arrangeGrob(p2, pleg2, ncol = 2, widths = grobwidths),
  arrangeGrob(p3, pleg3, ncol = 2, widths = grobwidths),
  arrangeGrob(p4, pleg4, ncol = 2, widths = grobwidths),
  ncol = 2, heights = c(1.25, 1)
)
dev.off()

@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/all_sens.pdf}
\caption{Size of confidence intervals (m) for \acl{doc} estimates in \cref{fig:all_ests}.  Points are colored and sized based on the difference between the upper and lower bounds of a 95\% confidence interval for all three \ac{doc} estimates ($Z_{c,\,min}$, $Z_{c,\,med}$, $Z_{c,\,max}$). Bounds were obtained using Monte Carlo simulations to estimate uncertainty associated with the inflection point of the estimated logistic curve (\cref{fig:est_ex}) for each sample. BB: Big Bend, CB: Choctawhatchee Bay, OTB: Old Tampa Bay, UIRL: Upper Indian R. Lagoon.}
\label{fig:all_sens}
\end{figure}

% satellite estimates of water clarity for Tampa Bay
<<choc_tb, echo = F, eval = F, cache = T, results = 'hide'>>=
options(digits = 7) 

# load data
data(choc_seg)
data(cb_sats)
sats_melt <- reshape2::melt(cb_sats[['sats_all']], id.var = c('lat', 'lon'))

# color ramp
cols <- c('blue', 'lightblue', 'yellow', 'brown')

# prep data
to_plo <- sats_melt
to_plo$variable <- factor(to_plo$variable, labels = c('Average', seq(2003, 2007)))
seg_plo <- fortify(choc_seg)

# leg lab
leg_lab <- bquote(italic(K [Z]) ~ .('(') ~ italic(m^-1) ~ .(')')) 

# make plot
p <- ggplot(data = seg_plo) +
  geom_polygon(aes(x = long, y = lat, group = id), 
    colour = 'black', fill = colors()[245]) +
  geom_tile(data = subset(to_plo, !is.na(value)), 
    aes(x = lon, y = lat, fill = value, colour = value)
  ) +
  geom_polygon(aes(x = long, y = lat, group = id), 
    colour = 'black', fill = NA) +
  coord_equal() +
  facet_wrap(~ variable, ncol = 2) + 
  scale_colour_gradientn(leg_lab, colours = cols) +
  scale_fill_gradientn(leg_lab, colours = cols) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.title.x = element_blank(), 
    axis.title.y = element_blank(),
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8)
    )

pdf('figs/kz_choc.pdf', height = 8, width = 8, family = 'serif')
p
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = \textwidth]{figs/kz_cb.pdf}
\caption{Satellite estimated water clarity for Choctawhatchee Bay based on empirical relationships between \textit{in situ} secchi observations and surface reflectance.  Each facet is an annual average of water clarity for available years of satellite data. The first facet is an average of all years.  See \cref{fig:light_cb} for segment identification.}
\label{fig:kz_cb}
\end{figure}


% satellite estimates of water clarity for Tampa Bay
<<kz_tb, echo = F, eval = T, cache = T, results = 'hide'>>=
options(digits = 7) 

# load data
data(tb_seg)
data(tb_sats)
sats_melt <- reshape2::melt(tb_sats[['sats_all']], id.var = c('lat', 'lon'))

# color ramp
cols <- c('blue', 'lightblue', 'yellow', 'brown')

# prep data
to_plo <- sats_melt
to_plo$variable <- factor(to_plo$variable, labels = c('Average', seq(2003, 2010)))
seg_plo <- fortify(tb_seg)

# leg lab
leg_lab <- bquote(italic(K [Z]) ~ .('(') ~ italic(m^-1) ~ .(')')) 

# make plot
p <- ggplot(data = seg_plo) +
  geom_polygon(aes(x = long, y = lat, group = id), 
    colour = 'black', fill = colors()[245]) +
  geom_tile(data = subset(to_plo, !is.na(value)), 
    aes(x = lon, y = lat, fill = value, colour = value)
  ) +
  geom_polygon(aes(x = long, y = lat, group = id), 
    colour = 'black', fill = NA) +
  coord_equal() +
  facet_wrap(~ variable) + 
  scale_colour_gradientn(leg_lab, colours = cols) +
  scale_fill_gradientn(leg_lab, colours = cols) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme_classic() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.title.x = element_blank(), 
    axis.title.y = element_blank(),
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8)
    )

pdf('figs/kz_tb.pdf', height = 7.5, width = 7, family = 'serif')
p
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = \textwidth]{figs/kz_tb.pdf}
\caption{Satellite estimated water clarity for Tampa Bay based on empirical relationships between \textit{in situ} secchi observations and surface reflectance.  Each facet is an annual average of water clarity for available years of satellite data. The first facet is an average of all years.  See \cref{fig:light_tb} for segment identification.}
\label{fig:kz_tb}
\end{figure}

% estimated light requirements for Tampa Bay
<<light_choc, echo = F, eval = T, cache = T, results = 'hide'>>=

source('R/funcs.r')

# load data
data(cb_sats)
data(choc_seg)
data(sgpts_2007_choc)
ave_rast <- cb_sats[['ave_rast']]

# create sampling grid, 0.01 dec degree spacing
choc_grd <- grid_est(choc_seg, 0.01)

# sample the satellit clarity raster
samp_vals <- raster::extract(ave_rast, choc_grd, sp = T) %>% 
  data.frame  
names(samp_vals) <- c('KZ', 'Longitude', 'Latitude')
coordinates(samp_vals) <- c('Longitude', 'Latitude')

# process for seagrass depth limits and light requirements
proc <- kz_doc(samp_vals, sgpts_2007_choc, choc_seg, radius = 0.2, trace = T)
dat <- na.omit(proc)

choc_light <- dat
save(choc_light, file = 'data/choc_light.RData')

# reset digits to default
options(digits = 7)

data(choc_light)
data(choc_seg)

# centroids for labels
labs <- data.frame(rgeos::gCentroid(choc_seg, byid = T))
labs$seg <- choc_seg$seg

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(choc_light)

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('z_c_all'), drop = F], to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max'])), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max'])), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none')

# boxplots by seg, z_cmax
# reorder seg labels
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  geom_boxplot(fill = fill_col) + 
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('light'), drop = F], to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(choc_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% light\nrequirements', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none')

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  geom_boxplot(fill = fill_col) + 
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

pdf('figs/light_choc.pdf', height = 7, width = 12, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.2, 0.2))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/light_tb.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Tampa Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.1 decimal degrees.  Estimates are also summarized by bay segment as boxplots where the dimensions are the 25\textsuperscript{th} percentile, median, and 75\textsuperscript{th} percentile.  Whiskers extend beyond the boxes as 1.5 multiplied by the interquartile range. HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:light_tb}
\end{figure}

% estimated light requirements for Tampa Bay
<<light_tb, echo = F, eval = T, cache = T, results = 'hide'>>=

# source('R/funcs.r')
# 
# # load data
# data(tb_sats)
# data(tb_seg)
# data(sgpts_2010_tb)
# ave_rast <- tb_sats[['ave_rast']]
# 
# # create sampling grid, 0.01 dec degree spacing
# tb_grd <- grid_est(tb_seg, 0.01)
# 
# # sample the satellit clarity raster
# samp_vals <- raster::extract(ave_rast, tb_grd, sp = T) %>% 
#   data.frame  
# names(samp_vals) <- c('KZ', 'Longitude', 'Latitude')
# coordinates(samp_vals) <- c('Longitude', 'Latitude')
# 
# # process for seagrass depth limits and light requirements
# proc <- kz_doc(samp_vals, sgpts_2010_tb, tb_seg, radius = 0.1, trace = T)
# dat <- na.omit(proc)
# 
# tb_light <- dat
# save(tb_light, file = 'data/tb_light.RData')

# reset digits to default
options(digits = 7)

data(tb_light)
data(tb_seg)

# centroids for labels
labs <- data.frame(rgeos::gCentroid(tb_seg, byid = T))
labs$seg <- c('HB', 'LTB', 'MTB', 'OTB')

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(tb_light)
# outs <- quantile(dat$light, c(0.05, 0.95))
# dat <- dat[dat$light > outs[1] & dat$light < outs[2],]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('z_c_all'), drop = F], to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max'])), range = scls, 
    breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max'])), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none')

# boxplots by seg, z_cmax
# reorder seg labels
segs <- c('LTB', 'MTB', 'HB', 'OTB')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  geom_boxplot(fill = fill_col) + 
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('light'), drop = F], to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(tb_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(labels = fmt()) + 
  xlab('Longitude') +
  scale_y_continuous(labels = fmt()) + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% light\nrequirements', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none')

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  geom_boxplot(fill = fill_col) + 
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

pdf('figs/light_tb.pdf', height = 7.5, width = 7, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()
@
\begin{figure}
\centering
\includegraphics[width = 0.95\textwidth]{figs/light_tb.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Tampa Bay, Florida. Locations are those where water clarity estimates were available from satellite observations and seagrass depth of colonization was estimable using a radius of 0.1 decimal degrees.  Estimates are also summarized by bay segment as boxplots where the dimensions are the 25\textsuperscript{th} percentile, median, and 75\textsuperscript{th} percentile.  Whiskers extend beyond the boxes as 1.5 multiplied by the interquartile range. HB: Hillsborough Bay, LTB: Lower Tampa Bay, MTB: Middle Tampa Bay, OTB: Old Tampa Bay.}
\label{fig:light_tb}
\end{figure}

% estimated light requirements for Indian River Lagoon
<<light_irl, echo = F, eval = T, cache = T, results = 'hide'>>=

# source('R/funcs.r')
# 
# # irl polygon segment
# data(irl_seg)
# 
# # irl secchi data
# data(secc_all)
# 
# # irl seagrass points
# data(sgpts_2009_irl)
# 
# # select only years within last ten of seagrass survey
# yrs <- strftime(secc_all$Date, '%Y') %>% 
#   as.numeric
# yrs <- yrs <= 2009 & yrs > 1999
# secc_all <- secc_all[yrs, ]
# 
# # remove stations with less than five observations
# rems <- table(secc_all$Station_ID)
# rems <- names(rems)[rems < 5]
# secc_all <- secc_all[!secc_all$Station_ID %in% rems, ]
# 
# # process, get ave secchi data results
# proc <- secc_doc(secc_all, sgpts_2009_irl, irl_seg, radius = 0.15, seg_pts_yr = '2009', trace = T)
# dat <- na.omit(proc$ave_dat)
# 
# irl_light <- dat
# save(irl_light, file = 'data/irl_light.RData')

# reset digits to default
options(digits = 7)

data(irl_light)

data(irl_seg)

# centroids for labels, offset
labs <- data.frame(rgeos::gCentroid(irl_seg, byid = T, id = irl_seg$seg))
labs$x <- labs$x - 0.3
labs$seg <- rownames(labs)
labs <- labs[!labs$seg %in% 'LHR', ]

fill_col <- colors()[245]

# format data, remove outliers
dat <- data.frame(irl_light)
# outs <- quantile(dat$light, c(0.05, 0.95))
# dat <- dat[dat$light > outs[1] & dat$light < outs[2],]

# color ramp for all graphs
pt_cols <- c('blue', 'lightblue', 'yellow', 'brown')

# legend formatting, z_cmax
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('z_c_all'), drop = F], to = scls)
leg_brks <- seq(min(dat$z_c_all, na.rm =  T), max(dat$z_c_all, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)

# map, z_cmax
p1 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = z_c_all), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = bquote(italic('Z' ['c, max'])), range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = bquote(italic('Z' ['c, max'])), 
    colours = rev(pt_cols),
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p1leg <- g_legend(p1)
p1 <- p1 + theme(legend.position = 'none')

# boxplots by seg, z_cmax
# reorder seg labels
segs <- c('LSL', 'LIRL', 'LCIRL', 'UCIRL', 'BR', 'UIRL', 'LML', 'UML')
dat$seg <- factor(dat$seg, levels = segs) 
p2 <- ggplot(dat, aes(x = seg, y = z_c_all)) + 
  geom_boxplot(fill = fill_col) + 
  ylab(bquote(italic('Z' ['c, max']))) +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

# legend formatting, light requirements
scls <- c(2, 9)
scl_vals <- scales::rescale(dat[, c('light'), drop = F], to = scls)
leg_brks <- seq(min(dat$light, na.rm =  T), max(dat$light, na.rm = T), length = 6)
leg_labs <- form_fun(leg_brks, 2, 2, 2)
  
# map, light requirements
p3 <- ggplot(fortify(irl_seg), aes(long, lat)) + 
  geom_polygon(colour = 'black', fill = fill_col, aes(group = id)) +
  geom_point(data = dat, aes(x = Longitude, y = Latitude, 
    colour = light), size = 3, fill = 'black', alpha = 0.8) +
  geom_text(data = labs, aes(label = seg, x = x, y = y)) +
  theme_classic() +
  coord_equal() +
  scale_x_continuous(limits = c(-81.3, -80)) + 
  xlab('Longitude') +
  scale_y_continuous() + 
  ylab('Latitude') +
  scale_size(name = '% light\nrequirements', range = scls, breaks = leg_brks, 
    labels = leg_labs) + 
  scale_colour_gradientn(name = '% light\nrequirements', 
    colours = pt_cols,
    breaks = leg_brks, labels = leg_labs) +
  guides(colour = guide_legend(), size = guide_legend()) + 
  guides(colour = guide_legend(), size = guide_legend())

p3leg <- g_legend(p3)
p3 <- p3 + theme(legend.position = 'none')

# boxplots, light requirements
p4 <- ggplot(dat, aes(x = seg, y = light)) + 
  geom_boxplot(fill = fill_col) + 
  ylab('% light requirements') +
  theme_classic() +
  theme(axis.title.y = element_blank()) + 
  coord_flip()

pdf('figs/light_irl.pdf', height = 8.5, width = 6.5, family = 'serif')
grid.arrange(p1, p1leg, p2, p3, p3leg, p4, ncol = 3, nrow = 2, 
  widths = c(1, 0.3, 0.75))
dev.off()

options(digits = 1)
@
\begin{figure}
\centering
\includegraphics[width = 0.8\textwidth]{figs/light_irl.pdf}
\caption{Estimated maximum depths of seagrass colonization and light requirements for multiple locations in Indian River Lagoon, Florida.  Map locations are georeferenced observations of water clarity in the Florida \acl{IWR} database, update 40.  Estimates are also summarized by bay segment as boxplots as in \cref{fig:light_tb}. Light requirements are based on averaged secchi values within ten years of the seagrass coverage data and estimated maximum depth of colonization using a radius of 0.02 decimal degrees for each secchi location to sample seagrass depth points. BR: Banana R., LCIRL: Lower Central Indian R. Lagoon, LIRL: Lower Indian R. Lagoon, LML: Lower Mosquito Lagoon, LSL: Lower St. Lucie, UCIRL: Upper Central Indian R. Lagoon, UIRL: Upper Indian R. Lagoon, UML: Upper Mosquito Lagoon.}
\label{fig:light_irl}
\end{figure}


\end{document}